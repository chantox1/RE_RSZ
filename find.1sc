//------------------------------------------------
//--- 010 Editor v12.0.1 Script File
//
//      File: motfsmv2
//   Authors: dtlnor
//   Version: 
//   Purpose: helper function for research
//  Category: 
//   History: 
//------------------------------------------------

//------------------------------------------------
// command here
//------------------------------------------------

// print & get murmurhash by input string
//hash_8("snow.player.fsm.PlayerFsm2ActionHunterWire");

// print & get type name by type murmurhash
//findHashName(0x212C209E); //snow.player.fsm.PlayerFsm2ActionHunterWire
/*
findHashName(0xADA3CEC1); //snow.player.fsm.PlayerHitAction2
findHashName(0x25887C4B); //snow.PlayerPlayMotion2

findHashName(0xAE2A3140); //snow.player.fsm.PlayerFsm2ActionGreatSwordHitAction
findHashName(0x9C966784); //snow.player.fsm.PlayerFsm2ActionLanceChargeHitAction
findHashName(0x3B1FED4E); //snow.player.fsm.PlayerHitCommonAction2

findHashName(0x7DD3D1DE); //snow.envCreature.EnvCreatureFsm2ActionHitSet
findHashName(0xEB7A4709); //snow.envCreature.EnvCreatureFsm2ActionEc003HitSet

findHashName(0xFA6B1BCC); //snow.player.fsm.PlayerHitAction2OverrideUsedHitAction
findHashName(0xC9A96C7B); //snow.player.fsm.PlayerFsm2ActionIG_InsectHitAction
findHashName(0x1A2E10B6); //snow.otomo.fsm.action.OtomoHitAction2
findHashName(0xD5832A24); //snow.otomo.fsm.action.OtomoMultiHitAction
*/

// print node info who ref to this type(by its type murmurhash)
//findHashOccurNode(0x212C209E); //*snow.player.fsm.PlayerFsm2ActionHunterWire[7853] 556540062
//findHashOccurNode(0x25887C4B); //snow.PlayerPlayMotion2
//findHashOccurNode(0xADA3CEC1); //snow.player.fsm.PlayerHitAction2
//findHashOccurNode(0xEA5D2BC6); //event(TransitionEvents)

// print node info who ref to this type by input type name directly
//findHashOccurNode(hash_8("snow.PlayerPlayMotion2"));

// print parent node which ref to this node
//searchNodePredecessor(3533);

//------------------------------------------------
// script below
//------------------------------------------------

//RSZ Parser By Darkness:
#link "RSZParser.dll"
ubyte   IsInitialized();
void    ParseJson(string jsonPath);
string  GetRSZClassName(uint32 classHash);
uint32  GetFieldCount(uint32 classHash);
uint32  GetFieldAlignment(uint32 classHash, uint32 fieldIndex);
ubyte   GetFieldArrayState(uint32 classHash, uint32 fieldIndex);
string  GetFieldName(uint32 classHash, uint32 fieldIndex);
string  GetFieldTypeName(uint32 classHash, uint32 fieldIndex);
string  GetFieldOrgTypeName(uint32 classHash, uint32 fieldIndex);
uint32  GetFieldSize(uint32 classHash, uint32 fieldIndex);
uint64  GetFieldType(uint32 classHash, uint32 fieldIndex);
ubyte   IsFieldNative(uint32 classHash, uint32 fieldIndex);
#endlink

local int i;
local int nodeCnt = BehaviorTree.NodeCount;

string findHashName(uint32 hashVal){
    if (!IsInitialized())
        ParseJson(JsonPath);
    local string className = GetRSZClassName(hashVal);
    Printf("%08X, %s\n",hashVal, className);
    return className;
}

uint32 hash_8(string key){
    local uint64 it<hidden=true>;
    local const uint length = Strlen(key);
    local uint32 mmhVal = 0;
    if (length) {
        local byte key_array[length];
        for(it = 0; it < length; it += 1){
            key_array[it] = key[it];
        }
        mmhVal = mmh3(key_array, length, 0xFFFFFFFF);
        Printf("%08Xh\n",mmhVal);
        return mmhVal;
    } return 0;
}


uint32 searchNodePredecessor(uint32 NodeID){
    local int varItr = 0;
    local uint i,j = 0;
    local int NodeCount = BehaviorTree.NodeCount;
    local int occurCount = 0;
    if (NodeCount <= NodeID) return 0;
    local uint BHVTHashID = BehaviorTree.RawNodes.Node[NodeID].ID.hash;

    Printf("Searching Node Predecessor\n");
    for (i=0; i<NodeCount; i++){
        if (exists(BehaviorTree.RawNodes.Node[i].Transitions.TransitionCount.Count)){
            for (j=0;j<BehaviorTree.RawNodes.Node[i].Transitions.TransitionCount.Count;j++){
				if (BehaviorTree.RawNodes.Node[i].Transitions.Transition[j].mStartState.hash == BHVTHashID){
					Printf("Node[%d](T),%s\n",i, BehaviorTree.RawNodes.Node[i].Name.String);
					occurCount++;
				}
			}
        }
        if (exists(BehaviorTree.RawNodes.Node[i].States.StatesCount.Count)){
            for (j=0;j<BehaviorTree.RawNodes.Node[i].States.StatesCount.Count;j++){
                if (BehaviorTree.RawNodes.Node[i].States.State[j].mTransitions.hash == BHVTHashID){
	                Printf("Node[%d](S),%s\n",i, BehaviorTree.RawNodes.Node[i].Name.String);
                    occurCount++;
                }
            }
        }
    }
    Printf("Search end\n");

    return occurCount;
}

void findHashOccurNode(uint32 typeMMH){ //search occur by murmurhash of type name 
    local TFindResults r;
    local uint i,j = 0;
    local int count=0;
    local uint instance_BHVTHash = 0;
    local int enable = 0;
    local int objectID = -1;
    
    if (findHashName(typeMMH) == "Unknown Class!") return;

    /*
        Actions = 0, // in action
        Selectors = 1,
        SelectorCallers = 2,
        Conditions = 3, // in transition / states
        TransitionEvents = 4, // in transition / states - mstates
        ExpressionTreeConditions = 5,
        StaticActions = 6,
        StaticSelectorCallers = 7,
        StaticConditions = 8,
        StaticTransitionEvents = 9,
        StaticExpressionTreeConditions = 10,
    */
    
    //Printf("%d\n", RSZFile[0].RSZHeader.objectCount);
    
    for (i = 0; i < 11; i++) {
	    if (RSZFile[i].RSZHeader.objectCount == 0) continue;
        for (j=0; j < RSZFile[i].RSZHeader.instanceCount; j++) {
            if (typeMMH == RSZFile[i].InstanceInfos.instanceInfo[j].typeId.Hash){
			    //searchOffset(i, typeMMH, j);
                objectID = searchObjByInst(i, j);
                Printf("RSZType[%d],typeHash:%08X,instIdx:%d,objIdx:%d",i, typeMMH, j, objectID);
                if (i == id_Actions || i == id_StaticActions){
			        instance_BHVTHash = GetRSZVarAsUint(i, typeMMH, j, 1);
			        enable = GetRSZVarAsUint(i, typeMMH, j, 0);

                    Printf(",BHVTHash(%d):%08X", enable, instance_BHVTHash);
                    if (GetNodeIDByActionBHVTHash(instance_BHVTHash) == 0)
                        Printf(",Node[NaN]ID:0x00000000");
                    if (typeMMH == 0xADA3CEC1)
	                    Printf(",workID:%d,hitIndex:%d" ,GetRSZVarAsUint(i, typeMMH, j, 3), GetRSZVarAsUint(i, typeMMH, j, 2));
                    if (typeMMH == 0x25887C4B)
                        Printf(",BankID:%d,MotionID:%d" ,GetRSZVarAsUint(i, typeMMH, j, 3), GetRSZVarAsUint(i, typeMMH, j, 4));
                    if (typeMMH == 556540062)
	                    Printf(",useNum:%d,recastTime:%d" ,GetRSZVarAsUint(i, typeMMH, j, 2), GetRSZVarAsUint(i, typeMMH, j, 3));

                } else if (i == id_Selectors) {
			        Printf("selector\n");
                    break;
                } else if (i == id_Conditions || i == id_StaticConditions) {
			        instance_BHVTHash = GetRSZVarAsUint(i, typeMMH, j, 0);
			        enable = GetRSZVarAsUint(i, typeMMH, j, 2);
                    
                    Printf(",BHVTHash(%d):%08X", enable, instance_BHVTHash);
                    if (GetNodeIDByConditionBHVTID(objectID, i) == 0)
                        Printf(",Node[NaN]ID:0x00000000");

                } else if (i == id_TransitionEvents /*|| i == id_StaticTransitionEvents*/) {
			        instance_BHVTHash = GetRSZVarAsUint(i, typeMMH, j, 0);
			        enable = GetRSZVarAsUint(i, typeMMH, j, 1);
                    
                    Printf(",BHVTHash(%d):%08X", enable, instance_BHVTHash);
                    if (GetNodeIDByTransitionBHVTID(objectID, i) == 0)
                        Printf(",Node[NaN]ID:0x00000000");

                } else if (i == id_ExpressionTreeConditions || i == id_StaticExpressionTreeConditions) {
			        instance_BHVTHash = GetRSZVarAsUint(i, typeMMH, j, 0);
			        enable = GetRSZVarAsUint(i, typeMMH, j, 2);
                    
                    Printf(",BHVTHash(%d):%08X", enable, instance_BHVTHash);

                }
                Printf("\n");
		        count++;
		    }
        }
	    Printf("RSZFile[%d] FoundCount:%d\n",i, count);
    }
}

int searchObjByInst(uint RSZType, uint instID){

    local uint k = 0;
    local int objectID = -1;
    for (k = 0; k < RSZFile[RSZType].RSZHeader.objectCount; k++){
        if(RSZFile[RSZType].ObjectTable[k] == instID){
            objectID = k;
            return objectID;
        }
    }
    return -1;
}

uint GetRSZVarAsUint(uint RSZType, uint typeMMH, uint instID, uint varIdx){
    //local int varItr = 0;
    if (exists(RSZFile[RSZType].Data.RawData.RSZ[instID].var[varIdx].data_As_Int))
        return RSZFile[RSZType].Data.RawData.RSZ[instID].var[varIdx].data_As_Int;
    return RSZFile[RSZType].Data.RawData.RSZ[instID].var[varIdx].data;
}

uint GetNodeIDByActionBHVTHash(uint ActionBHVTHash){
    local int varItr = 0;
    local uint i,j = 0;
    local int NodeCount = BehaviorTree.NodeCount;
    local int ActionCount = 0;
    local uint refActionBHVTHash = 0;
    local int occurCount = 0;
    
    for (i=0; i<NodeCount; i++){
        if (exists(BehaviorTree.RawNodes.Node[i].Actions.ActionsCount.Count)){
            //ActionCount = BehaviorTree.RawNodes.Node[i].Actions.ActionsCount.Count;
            for (j=0;j<BehaviorTree.RawNodes.Node[i].Actions.ActionsCount.Count;j++){
                //refActionBHVTHash = BehaviorTree.RawNodes.Node[i].Actions.Action[j].Action.hash;
                if (BehaviorTree.RawNodes.Node[i].Actions.Action[j].Action.hash == ActionBHVTHash){
                    if (occurCount > 0) {
	                    Printf(",Node[%d]ID:%08X,%s",i, BehaviorTree.RawNodes.Node[i].ID.hash, BehaviorTree.RawNodes.Node[i].Name.String);
                    }else{
	                    Printf(",Node[%d]ID:%08X,%s",i, BehaviorTree.RawNodes.Node[i].ID.hash, BehaviorTree.RawNodes.Node[i].Name.String);
                        //ReadBHVTHashName
                        //BHVTHash
                    }
                    occurCount++;
                }
            }
        }
    }
    //BehaviorTree.RawNodes.Node[kk]
    return occurCount;
}

uint GetNodeIDByTransitionBHVTID(uint TransitionBHVTID, uint BHVTlv){
    local int varItr = 0;
    local uint i,j,k,l = 0;
    local int NodeCount = BehaviorTree.NodeCount;
    local int TransitionCount = 0;
    local uint refTransitionBHVTID = 0;
    local int occurCount = 0;
    
    for (i=0; i<NodeCount; i++){
        if (exists(BehaviorTree.RawNodes.Node[i].States.StatesCount.Count)){
            for (j=0;j<BehaviorTree.RawNodes.Node[i].States.StatesCount.Count;j++){
                if (exists(BehaviorTree.RawNodes.Node[i].States.State[j].mStates.Count.Count)){
                    if (BehaviorTree.RawNodes.Node[i].States.State[j].mStates.Count.Count == 1){
                        if (BehaviorTree.RawNodes.Node[i].States.State[j].mStates.ID.id == TransitionBHVTID){
                            Printf(",State[%d],Node[%d]ID:%08X,%s",j ,i, BehaviorTree.RawNodes.Node[i].ID.hash, BehaviorTree.RawNodes.Node[i].Name.String);
                            for (l=0; l<NodeCount; l++)
                                if (BehaviorTree.RawNodes.Node[l].ID.hash == BehaviorTree.RawNodes.Node[i].States.State[j].mTransitions.hash)
                                    Printf(",->,Node[%d]ID:%08X,%s",l, BehaviorTree.RawNodes.Node[i].ID.hash, BehaviorTree.RawNodes.Node[l].Name.String);
                            occurCount++;
                        }
                    } else {
                        for (k=0;k<BehaviorTree.RawNodes.Node[i].States.State[j].mStates.Count.Count;k++){
                            if (BehaviorTree.RawNodes.Node[i].States.State[j].mStates.IDs.ID[k].id == TransitionBHVTID){
	                            Printf(",State[%d],Node[%d]ID:%08X,%s",j ,i, BehaviorTree.RawNodes.Node[i].ID.hash, BehaviorTree.RawNodes.Node[i].Name.String);
                                for (l=0; l<NodeCount; l++)
                                    if (BehaviorTree.RawNodes.Node[l].ID.hash == BehaviorTree.RawNodes.Node[i].States.State[j].mTransitions.hash)
                                        Printf(",->,Node[%d]ID:%08X,%s",l, BehaviorTree.RawNodes.Node[i].ID.hash, BehaviorTree.RawNodes.Node[l].Name.String);
                                occurCount++;
                            }
                        }
                    }
                }
            }
        }
    }
    return occurCount;
}

uint GetNodeIDByConditionBHVTID(uint ConditionBHVTID, uint BHVTlv){
    local int varItr = 0;
    local uint i,j,k,l = 0;
    local int NodeCount = BehaviorTree.NodeCount;
    local int ConditionCount = 0;
    local uint refConditionBHVTID = 0;
    local int occurCount = 0;
	local int isStatic = BHVTlv == 8;
    
    for (i=0; i<NodeCount; i++){
        if (exists(BehaviorTree.RawNodes.Node[i].States.StatesCount.Count)){
            for (j=0;j<BehaviorTree.RawNodes.Node[i].States.StatesCount.Count;j++){
				if (BehaviorTree.RawNodes.Node[i].States.State[j].TransitionConditions.id == ConditionBHVTID){
					if ((BehaviorTree.RawNodes.Node[i].States.State[j].TransitionConditions.idType == 64) == isStatic){
						Printf(",State[%d],Node[%d]ID:%08X,%s",j ,i, BehaviorTree.RawNodes.Node[i].ID.hash, BehaviorTree.RawNodes.Node[i].Name.String);
							for (l=0; l<NodeCount; l++)
								if (BehaviorTree.RawNodes.Node[l].ID.hash == BehaviorTree.RawNodes.Node[i].States.State[j].mTransitions.hash)
									Printf(",->,Node[%d]ID:%08X,%s",l, BehaviorTree.RawNodes.Node[i].ID.hash, BehaviorTree.RawNodes.Node[l].Name.String);
						occurCount++;
					}
				}
			}            
        }
        if (exists(BehaviorTree.RawNodes.Node[i].Transitions.TransitionCount.Count)){
            for (j=0;j<BehaviorTree.RawNodes.Node[i].Transitions.TransitionCount.Count;j++){
				if (BehaviorTree.RawNodes.Node[i].Transitions.Transition[j].mStartStateTransition.id == ConditionBHVTID){
					if ((BehaviorTree.RawNodes.Node[i].Transitions.Transition[j].mStartStateTransition.idType == 64) == isStatic){
						Printf(",Transition[%d],Node[%d]ID:%08X,%s",j ,i, BehaviorTree.RawNodes.Node[i].ID.hash, BehaviorTree.RawNodes.Node[i].Name.String);
							for (l=0; l<NodeCount; l++)
								if (BehaviorTree.RawNodes.Node[l].ID.hash == BehaviorTree.RawNodes.Node[i].Transitions.Transition[j].mStartState.hash)
									Printf(",->,Node[%d]ID:%08X,%s",l, BehaviorTree.RawNodes.Node[i].ID.hash, BehaviorTree.RawNodes.Node[l].Name.String);
						occurCount++;
					}
				}
			}
        }
    }
    return occurCount;
}

// deprecated
int searchSwitchActionOffset(uint RSZType, uint ActType, uint instID){
    local uint k = 0;
    local int objectID = -1;
    local int isTrueFalsePair = 0;
    local int returnTrueFalsePair = 0;
    local int isSingle = 0;
    for (k = 0; k < RSZFile[RSZType].RSZHeader.objectCount; k++){
        if(RSZFile[RSZType].ObjectTable[k] == instID){
            objectID = k;
            break;
        }
    }
    if (objectID >= 0){
        local uint32 arrayByte = objectID;
        if (RSZType > 5) arrayByte = (arrayByte + 0x40000000);

        local TFindResults r;
        r = FindAll( arrayByte );
        if (r.count == 0){ //try swape pair
            arrayByte = swapSet32(arrayByte);
            r = FindAll( arrayByte );
        }
        if (r.count == 0){ //try true false pair
            arrayByte = swapSet32(arrayByte);
            arrayByte = 0x40000000+objectID+1;
            arrayByte =  (arrayByte << 32) + 0x40000000 + objectID;
            r = FindAll( arrayByte );
            isTrueFalsePair = 1;
        }
        if (r.count == 0){ //try single
            isTrueFalsePair = 0;
            r = FindAll( (0x40000000 + objectID) );
            isSingle = 1;
        }
        if (r.count > 1){
            Printf("Duplicated: %016LX, %d, instID: %d, objID: %d\n",arrayByte, r.count, instID, objectID);
            local int k = 0;
            for (k = 0; k < r.count; k++){
                Printf("%Ld\n", r.start[k]);
            }
        }else if (r.count <= 0){
            Printf("Object not found: %016LX, %d, instID: %d, objID: %d\n",arrayByte, r.count, instID, objectID);
        }else if ( r.start[0] < boundStart || r.start[0] > boundEnd){ 
            Printf("Target out of bound, instID: %d\n",instID);
        }else { 
            // All fine
            if (isTrueFalsePair)  returnTrueFalsePair = 1;
            if (isSingle) {
                switch(ActType){
                    case AHash: {Printf( "A "); if (EnableA) { WriteUInt(r.start[0], 0xFFFFFFFF); Printf( "<> "); } }break;
                    case BHash: {Printf( "B "); if (EnableB) { WriteUInt(r.start[0], 0xFFFFFFFF); Printf( "<> "); } }break;
                    case CHash: {Printf( "C "); if (EnableC) { WriteUInt(r.start[0], 0xFFFFFFFF); Printf( "<> "); } }break;
                    default : Printf( "F "); break;
                }
                Printf( "%Ld %08X\n", r.start[0], (0x40000000 + objectID) );
            }else {
                switch(ActType){
                    case AHash: {Printf( "A "); if (EnableA) { WriteUInt64(r.start[0], swapSet32(arrayByte)); Printf( "<> "); } }break;
                    case BHash: {Printf( "B "); if (EnableB) { WriteUInt64(r.start[0], swapSet32(arrayByte)); Printf( "<> "); } }break;
                    case CHash: {Printf( "C "); if (EnableC) { WriteUInt64(r.start[0], swapSet32(arrayByte)); Printf( "<> "); } }break;
                    default : Printf( "F "); break;
                }
                Printf( "%Ld %016LX\n", r.start[0], arrayByte );
            }
        }
    }else{
        Printf("Object not found: %016LX, %d, instID: %d, objID: %d\n",arrayByte, r.count, instID, objectID);
    }
    return returnTrueFalsePair;
}

//from re_rsz
uint32 mmh3 (byte key[], uint32 length , uint32 seed){
    local uint64 block_start<hidden=true>;
    local const uint nBlocks = length / 4;
    local uint32 h1 = seed;
    
    local const uint32 c1 = 0xcc9e2d51;
    local const uint32 c2 = 0x1b873593;

    local uint32 k1;
    for(block_start = 0; block_start < nBlocks * 4; block_start+= 4){
        k1 = (uint32)key[block_start + 3] << 24 | \
             (uint32)key[block_start + 2] << 16 | \
             (uint32)key[block_start + 1] << 8 | \
             (uint32)key[block_start + 0];

        k1 = (c1 * k1) & 0xFFFFFFFF;
        k1 = (k1 << 15 | k1 >> 17) & 0xFFFFFFFF;
        k1 = (c2 * k1) & 0xFFFFFFFF;

        h1 ^= k1;
        h1 = (h1 << 13 | h1 >> 19) & 0xFFFFFFFF;
        h1 = (h1 * 5 + 0xe6546b64) & 0xFFFFFFFF;
    }

    local uint32 tail_index = nBlocks * 4;
    k1 = 0;
    local uint32 tail_size = length & 3;

    if(tail_size >= 3)
        k1 ^= (uint32)key[tail_index + 2] << 16;
    if(tail_size >= 2)
        k1 ^= (uint32)key[tail_index + 1] << 8;
    if(tail_size >= 1)
        k1 ^= (uint32)key[tail_index + 0];

    if(tail_size > 0){
        k1 = (k1 * c1) & 0xFFFFFFFF;
        k1 = (k1 << 15 | k1 >> 17) & 0xFFFFFFFF;
        k1 = (k1 * c2) & 0xFFFFFFFF;
        h1 ^= k1;
    }

    return fmix32(h1 ^ length);
}