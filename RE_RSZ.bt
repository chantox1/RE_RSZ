//------------------------------------------------
//--- 010 Editor v9.0.2 Binary Template
//
//      File: RE_RSZ.bt
//   Authors: alphaZomega w/ help from Darkness and Praydog
//   Version: 0.62
//   Purpose: Parsing RE Engine RSZ data
//  Category: RE Engine
// File Mask: *.user.2;*.pfb.*;*.scn.*;*.rcol.*;*.bhvt.*;*.motfsm2.*;*.fsmv2.*
//  ID Bytes: 
//   History: October 26, 2021



//------------------------------------------------
//              Option:                                                           //Effect:
local string    RSZVersion       <hidden=false>       = "MHRise";                    //change between RE2, RE3, RE8 or DMC5
local int       Nesting          <hidden=true>        = TRUE;                      //Attempt to nest class instances inside eachother
local int       ShowAlignment    <hidden=true>        = TRUE;                     //Show metadata for each variable
local int       ShowChildRSZs    <hidden=true>        = TRUE;                     //Show all RSZs one after another, non-nested. Disabling hides nested RSZHeaders
local int       UseSpacers       <hidden=true>        = TRUE;                      //Show blank rows between some structs
local int       AutoDetectGame   <hidden=true>        = TRUE;                      //Automatically detect RSZVersion based on the name + ext of the file being viewed
local int       ReadBHVTHeader   <hidden=true>        = TRUE;                      //Read BHVT header with UVAR
local int       RedetectBHVT     <hidden=true>        = TRUE;                      //Will automatically redetect the next BHVT node if there is a problem 
local int       HideRawData      <hidden=true>        = FALSE;                     //Hides RawData struct
local int       HideRawNodes     <hidden=true>        = FALSE;                      //Hides RawNodes struct
local int       SortRequestSets  <hidden=true>        = TRUE;                      //Sorts RCOL RequestSets by their IDs
local int       ExposeUserDatas  <hidden=true>        = TRUE;                      //Makes RSZFiles that contain embedded userDatas start after the Userdatas, for ctrl+J

//Path to Noesis.exe
local wstring NoesisPath <hidden=true> =            "C:\\MyProgram\\RETool\\noesisv4456\\Noesis.exe";

//Game							                    //Extracted Path
local wstring DMC5Path <hidden=true> =              "D:\\modmanager\\REtool\\DMC_chunk_000\\natives\\x64\\";
local wstring RE2Path <hidden=true> =               "D:\\modmanager\\REtool\\RE2_chunk_000\\natives\\x64\\";
local wstring RE3Path <hidden=true> =               "D:\\modmanager\\REtool\\RE3_chunk_000\\natives\\stm\\";
local wstring RE7Path <hidden=true> =               "D:\\modmanager\\REtool\\RE7_chunk_000\\natives\\x64\\";
local wstring RE8Path <hidden=true> =               "D:\\modmanager\\REtool\\RE8_chunk_000\\natives\\stm\\";
local wstring MHRPath <hidden=true> =               "C:\\Program Files (x86)\\Steam\\steamapps\\common\\MonsterHunterRiseDemo\\re_chunk_000_raw\\natives\\stm\\";


//RSZ Parser By Darkness:
#link "RSZParser.dll"
ubyte   IsInitialized();
void    ParseJson(string jsonPath);
string  GetRSZClassName(uint32 classHash);
uint32  GetFieldCount(uint32 classHash);
uint32  GetFieldAlignment(uint32 classHash, uint32 fieldIndex);
ubyte   GetFieldArrayState(uint32 classHash, uint32 fieldIndex);
string  GetFieldName(uint32 classHash, uint32 fieldIndex);
string  GetFieldTypeName(uint32 classHash, uint32 fieldIndex);
string  GetFieldOrgTypeName(uint32 classHash, uint32 fieldIndex);
uint32  GetFieldSize(uint32 classHash, uint32 fieldIndex);
uint64  GetFieldType(uint32 classHash, uint32 fieldIndex);
ubyte   IsFieldNative(uint32 classHash, uint32 fieldIndex);
#endlink

//Local variables:
local int i <hidden=true>, j <hidden=true>, k <hidden=true>, m <hidden=true>, n <hidden=true>, o <hidden=true>, h <hidden=true>, temp <hidden=true>,
            matchSize <hidden=true>, lastGameObject <hidden=true>, uniqueHashes[5000] <hidden=true>, hashesLen <hidden=true>, noRetry <hidden=true>;
local int RSZOffset <hidden=true> = FindFirst("RSZ",1,0,0,0.0,1,0,0,24);
local int start <hidden=true> = FindFirst("BHVT",1,0,0,0.0,1,0,0,24);
local uint realStart <hidden=true> = -1;
local int BHVTOffset <hidden=true> = start;
local int level <hidden=true>;
local int finished <hidden=true>;
local int broken <hidden=true>;
local string s <hidden=true>;
local wstring tempWString <hidden=true>;
local ubyte isAIFile <hidden=true>;
local char magic[4] <hidden=true>; 


if (detectedHash(4) && !detectedHash(0))
    ReadBytes(magic, 4, 4);
else ReadBytes(magic, 0, 4);

if (ShowAlignment) {
    local int varLen <hidden=false>;
    local uint maxVars <hidden=true> = ((FileSize()-RSZOffset)/4); 
    if (maxVars > 1000000) maxVars = 1000000;
    local uint offs[maxVars] <hidden=false>, aligns[maxVars] <hidden=false>, sizes[maxVars] <hidden=false>; //synced
} else {
    local int varLen <hidden=true>;
}

local wstring extractedDir <hidden=true> = DMC5Path;
local wstring Local_Directory  <hidden=true> = FileNameGetPath(GetFileName(), true);
local uint findValue <hidden=true> = find(Local_Directory, "natives");
Local_Directory = StrDel( Local_Directory, findValue, sizeof(Local_Directory) - findValue) + "natives\\";
local wstring lower <hidden=true> = Lower(Local_Directory);

if (AutoDetectGame) {
    local string xFmt <hidden=true> = "x64\\";
    if (find(lower, "dmc") != -1 || find(lower, "evil may") != -1) {
	    RSZVersion = "DMC5";
	    extractedDir = DMC5Path;

    } else if (find(lower, "re2") != -1 || find(lower, "evil 2") != -1) {
	    RSZVersion = "RE2";
	    extractedDir = RE2Path;

    } else if (find(lower, "re3") != -1 || find(lower, "evil 3") != -1) {
	    RSZVersion = "RE3";
	    extractedDir = Lower(RE3Path);
	    xFmt = "stm\\";

    } else if (find(lower, "re8") != -1 || find(lower, "evil 8") != -1 || find(lower, "illage") != -1) {
	    RSZVersion = "RE8";
	    extractedDir = Lower(RE8Path);
	    xFmt = "stm\\";
    } else if (find(lower, "re7") != -1 || find(lower, "evil 7") != -1) {
	    RSZVersion = "RE7";
	    extractedDir = Lower(RE7Path);
	    xFmt = "x64\\";
    } else if (find(lower, "mhr") != -1 || find(lower, "nter R") != -1 || find(lower, "Rise") != -1) {
	    RSZVersion = "MHRise";
	    extractedDir = Lower(MHRPath);
	    xFmt = "stm\\";
    } 
	Local_Directory += xFmt;

} else if (RSZVersion == "DMC5" || RSZVersion == "RE2" || RSZVersion == "RE7") {
    Local_Directory += "x64\\";
} else {
    Local_Directory += "stm\\";
}
Local_Directory = Lower(Local_Directory);
local string JsonPath<hidden=true> = Lower(FileNameGetPath(GetTemplateFileName()) + "RSZ" + RSZVersion + ".json"); 
ParseJson(JsonPath);

//===========================
//Create your own enums here:
//They will be added inside the struct for any variable with the name detected by findS()
void enums(){
    if (fieldName == "GroupName_Role") {
        FSkip(-sizeof(data));
        enum {
            role_Normal =  0,
            role_Idle =  1,
            role_SitFakeDead =  2,
            role_LieFakeDead =  3,
            role_Hypnotized =  4,
            role_LieHypnotized =  5,
            role_standingIdle =  6,
            role_Eating =  7,
            role_Special =  8,
            role_BreakDownDoor =  9,
            role_HangingFakeDead =  10,
            role_SplitInHalf =  11,
            role_Dead =  12,
            role_DeadPosed =  13,
            role_DeadPosed2 =  14,
            role_DeadPosed3 =  15,
        }GroupName_Role;
    }
    else if (findS(fieldName, "DamageType") != -1) {
        FSkip(-sizeof(data));
        enum { 
            None = -1,
            Minimum = 0,
            NormalS = 1,
            NormalL = 2,
            NormalLL = 3,
            Down = 4,
            DownBound = 5,
            Slam = 6,
            SlamBound = 7,
            Upper = 8,
            HyperUpper = 9,
            HyperUpperAir = 10,
            Blown = 11,
            Collapse = 12,
            RollingUpper = 13,
            CheckSpin = 14,
            Spin = 15,
            DiagonalBlown = 16,
            WindS = 17,
            WindL = 18,
            SnatchRelase = 19,
            StraightBlown = 20,
            Tremor = 21,
            Inhale = 22,
            MotionContinue = 23,
            Explosion = 24
        } DamageType;
    }
}

//============================
//Special functions & structs:
LittleEndian();
if (AutoDetectGame && RSZVersion != "RE7")
    AutoDetectVersion();

void AutoDetectVersion() {
    local string hashName;
    local uint checkedVersions, instanceCount, objectCount, hash, zz, varsChecked;
    local string origVersion = RSZVersion, origExtractedDir = (string)extractedDir, origXFmt = xFmt, origLocal_Directory = Local_Directory, origJsonPath = JsonPath;
    FSeek(RSZOffset);
    instanceCount = ReadUInt(FTell() + 12), objectCount = ReadUInt(FTell() + 8);
    if (instanceCount) {
        FSeek(ReadUInt(RSZOffset+24) + RSZOffset + 8);
        //if (ReadUInt64() != 0) {
        //    if (RSZVersion != "RE7")
        //        Printf("RSZVersion auto detected to RE7\n");
        //    RSZVersion = "RE7"; extractedDir = RE7Path; xFmt = "x64\\";
        //    return;
        //}
        for (zz=1; zz<instanceCount; zz++) {
            if (varsChecked > 100) break;
            hash = ReadUInt();
            hashName = ReadHashName(hash);
            checkedVersions = 0;
            if (hash != 0 && checkedVersions < 5 && hashName == "Unknown Class!") {
                Printf("%s %i %i\n", hashName, zz, FTell());
                while (checkedVersions < 5 && hashName == "Unknown Class!") {
                    switch (checkedVersions) {
                        case 0: RSZVersion = "DMC5"; extractedDir = DMC5Path; xFmt = "x64\\";  break;
                        case 1: RSZVersion = "RE2"; extractedDir = RE2Path; xFmt = "x64\\"; break;
                        case 2: RSZVersion = "RE3"; extractedDir = RE3Path; xFmt = "stm\\"; break;
                        case 3: RSZVersion = "RE8"; extractedDir = RE8Path; xFmt = "stm\\"; break;
                        case 4: RSZVersion = "MHRise"; extractedDir = MHRPath; xFmt = "stm\\"; break;
                        //case 5: RSZVersion = "RE7"; extractedDir = RE7Path; xFmt = "x64\\"; break;
                    }
                    Local_Directory = lower + xFmt; JsonPath = Lower(FileNameGetPath(GetTemplateFileName()) + "RSZ" + RSZVersion + ".json");
                    ParseJson(JsonPath);
                    hashName = ReadHashName(hash);
                    checkedVersions++;
                }
                if (checkedVersions == 3 && hashName == "Unknown Class!") {
                    RSZVersion = origVersion; extractedDir = origExtractedDir; xFmt = origXFmt; Local_Directory = origLocal_Directory; JsonPath = origJsonPath;
                } else {
                    Printf("RSZVersion auto detected to %s\n", RSZVersion);
                    break;
                }
            }
            varsChecked++;
            FSkip(8);
            if (varsChecked > 15) 
                break;
        }
    }
    FSeek(0);
}


void align(uint alignment) { 
    while (FTell() % alignment != 0 && FTell() <= FileSize()) 
    FSkip(1); 
}

int detectedColorVector(uint64 tell) { 
    if (tell+16<=FileSize()) {
        local float R = ReadFloat(tell), G = ReadFloat(tell+4), B = ReadFloat(tell+8), A = ReadFloat(tell+12); 
        return ((R >= 0 && G >= 0 && B >= 0 && (A == 0 || A == 1)) && ((R+G+B+A <= 4) || (R+G+B+A) % 1.0 == 0));
    } return 0;
}

float readColorFloat(uint64 tell) {
	local float colorFlt = ReadFloat(tell); 
    if (colorFlt <= 1) {
        colorFlt = (uint)(colorFlt * 255.0f + 0.5);
	    if (colorFlt > 255) 
		    return 255;
    }
	return colorFlt ; 
}

int detectedFloat(uint64 offset) {
    if (offset+4 <= FileSize()) {
        local float flt = ReadFloat(offset);
        if (BHVTOffset != -1)
            return (ReadUByte(offset+3) < 255 && (Abs(flt) > 0.000001 && Abs(flt) < 100000) || ReadInt(offset) == 0); 
        else return (ReadUByte(offset+3) < 255 && (Abs(flt) > 0.0000001 && Abs(flt) < 10000000) || ReadInt(offset) == 0);
    } return false;
}

int detectedStringSm(uint64 offset) {
    if (offset+4 <= FileSize())
        if (ReadUShort(offset-2) == 0)
            if (ReadByte(offset) != 0 || ReadUShort(offset) == 0)
                if (ReadByte(offset + 1) == 0 || sizeof(ReadWString(offset)) > 5) 
                    //if (sizeof(ReadWString(offset)) >= 2)
                        return true;
    return false;
}

int detectedString(uint64 offset) { 
    if (offset+6 <= FileSize())
        if (ReadByte(offset) != 0 && ReadByte(offset + 1) == 0) 
            if (ReadByte(offset + 2) != 0 && ReadByte(offset + 3) == 0)
                if (ReadByte(offset + 4) != 0) // && ReadByte(offset + 5) == 0
                    return true;
    return false;
}

int detectedNode (uint tell) {
    if (tell+12<FileSize())
        if (ReadInt(tell-4) == 0)
            if (ReadInt(tell) != -1) 
                if (detectedHash(tell))
                    if (ReadInt(tell+8) != 0)
                        if (detectedStringSm(startof(Header.BHVT.mNamePool) + 4 + (ReadUInt(tell+8)*2)))
                            return true;
    return false;
}

int find(wstring str, wstring term) { return (RegExSearch(str, term, matchSize, 0)); }

int findS(string str, string term) { return (RegExSearch(str, term, matchSize, 0)); }

wstring Lower(wstring s1) { local string s = s1, s2 = s; for (k=0; k < sizeof(s); k++) s2[k] = ToLower(s[k]); return s2; }

wstring Upper(wstring s1) { local string s = s1, s2 = s; for (k=0; k < sizeof(s); k++) s2[k] = ToUpper(s[k]); return s2; }

int detectedBools(uint tell) {
    local uint nonBoolTotal;
    for (o=0; o<4; o++)
        if (ReadUByte(tell + o) > 1)
            nonBoolTotal++;
    if (nonBoolTotal == 0)
        return true;
    return false;
}

uint detectedHash(uint tell) {
    local ubyte nonHashTotal;
    for (o=0; o<4; o++)
        if (ReadUByte(tell + o) == 0)
            nonHashTotal++;
    if (nonHashTotal <= 1)
        return true;
    return false;
}

void FileOpener(wstring path) { 
    local wstring tmpNm = GetTemplateFileNameW();
    if (FileExists(NoesisPath) && (find(path, ".mesh.") != -1 || find(path, ".tex.") != -1)) {
        Exec(NoesisPath, "\"" + path + "\"", 0);
	    FileOpen(path, TRUE, "hex", 0); 
    } else FileOpen(path, TRUE, "hex", 0);
    FileSelect(FindOpenFileW(path));
	if (GetTemplateFileNameW() == "")
		RunTemplate(tmpNm, 0);
}

typedef byte BLANK <name=readBLANK, read=readBLANK>;

    string readBLANK(BLANK &ref) { return " ";}

    string ReadErrorNotice(BLANK &b) { return "[Read Error Adjustment]"; }

    string ReadUserDataNotice(BLANK &b) { return "[Embedded UserDatas]"; }

    string ReadMainDataNotice(BLANK &b) { return "[Main Data]"; }

    void checkUseSpacers() {
        if (UseSpacers) {
            FSkip(-1); 
            BLANK blank;
        }
    }

typedef enum <uint32> {
	ukn_error = 0,
	ukn_type,
	not_init,
	class_not_found,
	out_of_range,
	Undefined_tid,
	Object_tid,
	Action_tid,
	Struct_tid,
	NativeObject_tid,
	Resource_tid,
	UserData_tid,
	Bool_tid,
	C8_tid,
	C16_tid,
	S8_tid,
	U8_tid,
	S16_tid,
	U16_tid,
	S32_tid,
	U32_tid,
	S64_tid,
	U64_tid,
	F32_tid,
	F64_tid,
	String_tid,
	MBString_tid,
	Enum_tid,
	Uint2_tid,
	Uint3_tid,
	Uint4_tid,
	Int2_tid,
	Int3_tid,
	Int4_tid,
	Float2_tid,
	Float3_tid,
	Float4_tid,
	Float3x3_tid,
	Float3x4_tid,
	Float4x3_tid,
	Float4x4_tid,
	Half2_tid,
	Half4_tid,
	Mat3_tid,
	Mat4_tid,
	Vec2_tid,
	Vec3_tid,
	Vec4_tid,
	VecU4_tid,
	Quaternion_tid,
	Guid_tid,
	Color_tid,
	DateTime_tid,
	AABB_tid,
	Capsule_tid,
	TaperedCapsule_tid,
	Cone_tid,
	Line_tid,
	LineSegment_tid,
	OBB_tid,
	Plane_tid,
	PlaneXZ_tid,
	Point_tid,
	Range_tid,
	RangeI_tid,
	Ray_tid,
	RayY_tid,
	Segment_tid,
	Size_tid,
	Sphere_tid,
	Triangle_tid,
	Cylinder_tid,
	Ellipsoid_tid,
	Area_tid,
	Torus_tid,
	Rect_tid,
	Rect3D_tid,
	Frustum_tid,
	KeyFrame_tid,
	Uri_tid,
	GameObjectRef_tid,
	RuntimeType_tid,
	Sfix_tid,
	Sfix2_tid,
	Sfix3_tid,
	Sfix4_tid,
	Position_tid,
	F16_tid,
	End_tid,
	Data_tid
} TypeIDs;

typedef struct VARDATA(uint algn) {
    local ubyte alignment = algn;
    local uint offset = FTell();//getAlignedOffset(FTell(), algn);
    local uint varSz = offset; //placeholder
    local ubyte padding = offset - FTell();
    local ushort lvl <hidden=true>;
    if (exists(parentof(this).lvl)) 
        lvl = parentof(this).lvl;
    else 
        lvl = getLevel(FTell());
    
    if (!finished && ShowAlignment) {
        local uint varIdx = varLen;
        varLen++;
        if (ShowAlignment && offs[varIdx] == 0) {
            if ( varIdx != 0 && offs[varIdx-1] >= offset) { //new vars at the same offset overwrite old ones
                varLen--;
                varIdx--;
            } else {
                offs[varIdx] = offset;
                aligns[varIdx] = alignment;
                sizes[varIdx] = -1;
            }
        }
    }
    if (FTell() < FileSize())
        ubyte varStart <hidden=true>;
    else 
        Printf("End of File\n");
};

uint getAlignedOffset(uint tell, uint alignment) {
    local uint offset = tell;
    switch (alignment) {
        case 2:  offset = tell + (tell % 2); break;  //2-byte
        case 4:  offset = (tell + 3) & 0xFFFFFFFFFFFFFFFC; break;  //4-byte
        case 8:  offset = (tell + 7) & 0xFFFFFFFFFFFFFFF8; break;  //8-byte
        case 16: offset = (tell + 15) & 0xFFFFFFFFFFFFFFF0; break; //16-byte
        default: break;
    }
    return offset;
}

typedef struct(int listSize) {
    local ubyte listSize <hidden=true> = listSize;
    int Count;
} BHVTCount <read=ReadBHVTCount, write=WriteBHVTCount>;

string ReadBHVTCount(BHVTCount &c) { local string s; SPrintf(s, "%i", c.Count); return s; }

void WriteBHVTCount(BHVTCount &c, string s) {
    local int newCount = Atoi(s);
    if (newCount - c.Count > 0) { 
        local int k; 
        local int temp;
        local int addedSz = ((newCount - c.Count) * 4 * c.listSize);
        
        if ( ((newCount - c.Count) * 4 * c.listSize) % 16 != 0) {
            while ((RSZOffset + addedSz + temp) % 16 != RSZOffset % 16) 
                temp++;
        }

        addedSz += temp;
        Header.BHVT.actionOffset += addedSz;
        FixOffsets(0, 208, RSZOffset, addedSz, 0);
        
        local int tt;
        while(exists(RSZFile[tt])) {
            if (!RSZFile[tt].isUserData)
                FixOffsets(startof(RSZFile[tt]) + addedSz, startof(RSZFile[tt].RSZHeader)+48, RSZOffset, addedSz, 0);
            tt++;
        } 
        //Printf("==========================================================\n");
        tt=0;
        
        while (exists(Header.BHVT.Uvar[tt])) {
            FixOffsets(startof(Header.BHVT.Uvar[tt]), 56+startof(Header.BHVT.Uvar[tt].Header.magic), RSZOffset, addedSz, 0);
            if (exists(Header.BHVT.Uvar[tt].Data)) 
                FixOffsets(startof(Header.BHVT.Uvar[tt].Data), startof(Header.BHVT.Uvar[tt]) + sizeof(Header.BHVT.Uvar[tt]), RSZOffset, addedSz, 0);
            else 
                FixOffsets(getAlignedOffset(startof(Header.BHVT.Uvar[tt]) + sizeof(Header.BHVT.Uvar[tt]), 16), 
                32+getAlignedOffset(startof(Header.BHVT.Uvar[tt]) + sizeof(Header.BHVT.Uvar[tt]), 16), RSZOffset, addedSz, 0);
            tt++;
            break;
        }
        if (exists(Header.BHVT.Uvar[tt-1])) 
            FixOffsets(getAlignedOffset(startof(Header.BHVT.Uvar[tt-1]) + sizeof(Header.BHVT.Uvar[tt-1]), 16), FileSize(), RSZOffset, addedSz, 0);
        
        for (k=c.listSize; k>0; k--) 
            InsertBytes(startof(c) + 4 + (c.Count*4) * k, 4 * (newCount - c.Count), 0);
        if (temp)
            InsertBytes(RSZOffset, temp, 0);
        ShowRefreshMessage("");
    }
    c.Count = newCount;
}

void ShowRefreshMessage(string extraMsg) {
    MessageBox( idOk, "Insert Data", "%sPress F5 to refresh the template and fix template results", extraMsg);
}

//General offset fixer
void FixOffsets(uint64 tell, uint64 limitPoint, uint64 insertPoint, uint64 addedSz, int doInt32) {
    if (tell > limitPoint)
        return;
    local uint64 pos = FTell();
    local int64 tmp;
    local int varSize = 8 + -4 * doInt32;
    FSeek(tell);
    while(FTell() + varSize <= limitPoint) {
        if (FTell()+varSize > FileSize()) 
            break;
        if (doInt32==1)
            tmp = ReadInt(FTell());
        else tmp = ReadInt64(FTell());
        //Printf("%i  >? %i @ %i (limit %i)\n", tmp, insertPoint, FTell(), limitPoint );
        if (tmp >= insertPoint && tmp < FileSize()) {
            if (doInt32==1) 
                tmp = WriteUInt(FTell(), tmp+addedSz);
            else WriteUInt64(FTell(), tmp + addedSz);
        }
        FSkip(varSize);
    }
}

//Sorts array in ascending order, then sorts array2 by array (from Che)
void quicksort( int low, int high, uint array[], uint array2[] ) {
    local int i = low;
    local int j = high;
    local int temp = 0;
    local int z = array[(low + high) / 2]; // Choose a pivot value
    while( i <= j ) { // Partition the data
        while( array[i] < z ) // Find member above
            i++;
        while( array[j] > z ) // Find element below
            j--;
        if( i <= j )  {
            // swap two elements 
            temp     = array[i];
            array[i] = array[j]; 
            array[j] = temp;
            temp     = array2[i];
            array2[i] = array2[j]; 
            array2[j] = temp;
            i++; 
            j--;
        }
    }
    // Recurse
    if( low < j )  
        quicksort( low, j, array, array2 );
    if( i < high ) 
        quicksort( i, high, array, array2 ); 
}

//re-aligns variables, given the index of the first variable after the change (varIdx), the offset at the end of the change (tell), and the amount of bytes lost/gained (sizeChange):
void fixAlignment(uint varIdx, uint tell, uint sizeChange) {
    local int diff;
    local int oldPadding;
    
    //apply original size difference to all offsets after the change:
    for (m=varIdx+1; m<varLen; m++) 
        offs[m] += sizeChange;
    
    //remove all old padding from after the change:
    for (m=varLen-3; m>varIdx; m--) {
        oldPadding = offs[m+1] - (offs[m] + sizes[m]);
        
        if (oldPadding > 0) {
            //Printf("%u deleting %i bytes from %u\n", m, oldPadding, offs[m+1] - oldPadding);
            DeleteBytes(offs[m+1] - oldPadding, oldPadding);
        }
        for (o=varLen-1; o>m; o--) 
            offs[o] -= oldPadding;
    }
    
    //remove old padding from struct directly following the change:
    oldPadding = offs[varIdx+1] - tell;
    if (oldPadding > 0) {
        DeleteBytes(tell, oldPadding);
        for (o=varIdx+1; o<varLen; o++) 
            offs[o] -= oldPadding;
    }
    
    //add new padding for each variable based on its type:
    for (m=varIdx+1; m<varLen; m++) {
        offs[m] += diff;
        while (aligns[m] && offs[m] % aligns[m] != 0) {
            InsertBytes(offs[m], 1, 0);
            offs[m] += 1;
            diff += 1;
        }
    }
    ShowRefreshMessage("");
}

void setSize() {
    if (exists(Alignment.varStart)) {
        Alignment.varSz = FTell() - startof(Alignment.varStart);
        if (ShowAlignment && !finished && sizes[Alignment.varIdx] == -1) 
            sizes[Alignment.varIdx] = Alignment.varSz;
    }
}

void setAlignment(uint algn) {
    if (ShowAlignment)
        struct VARDATA Alignment(algn) <name="Alignment">;
    else
        struct VARDATA Alignment(algn) <name="Alignment", hidden=true>;
    FSkip(-1);
}

int getLevel(uint offset) {
    local int L = 0;
    for (L=0; L<level; L++)
        if (offset >= startof(RSZFile[L].Data) && offset < startof(RSZFile[L].Data) + sizeof(RSZFile[L].Data))
            break;
    return L;
}

int getLevelRSZ(uint offset) {
    local int L;
    for (L=0; L<level; L++)
        if (offset >= startof(RSZFile[L].RSZHeader) && offset <= startof(RSZFile[L].RSZHeader) + 16 + 64 * isAIFile)
            break;
    return L;
}

typedef struct {
    uchar uuid[16] <open=suppress>;
    if (false && exists(RSZFile) && exists(GameObjectInfos.GameObjectInfo.Guid)) {
        local ushort lvl <hidden=true> = level; 
        if (exists(parentof(this).lvl)) 
            lvl = parentof(this).lvl;
        if (!RSZFile[lvl].isUserData) {
            for (o=0; o<Header.infoCount; o++) {
                if (GameObjectInfos.GameObjectInfo[o].Guid.uuid == uuid && exists(RSZFile[lvl].ObjectTable[GameObjectInfos.GameObjectInfo[o].id.id])) {
                    local string GameObjectRef <open=suppress>;
                    if (exists(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[GameObjectInfos.GameObjectInfo[o].id.id]].var[0].data))
                        SPrintf(GameObjectRef, "via.GameObject[%u] -- %s", RSZFile[lvl].ObjectTable[GameObjectInfos.GameObjectInfo[o].id.id], RSZFile[lvl].Data.RawData.RSZ[ObjectTable[GameObjectInfos.GameObjectInfo[o].id.id]].var[0].data);
                    else if (exists(RSZFile[lvl]))
                        SPrintf(GameObjectRef, "%s[%u]", RSZFile[lvl].InstanceInfos.instanceInfo[ RSZFile[lvl].ObjectTable[GameObjectInfos.GameObjectInfo[o].id.id] ].typeId.HashName, RSZFile[lvl].ObjectTable[GameObjectInfos.GameObjectInfo[o].id.id]);
                    break;
                }
            }
        }
    }
} rGUID <read=ReadrGUID, write=WriterGuid, comment=ReadrGUIDComment>;

    string TranslateGUID (uchar uuid[]) {
        local char s[37];
        SPrintf(s, 
            "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x", 
            uuid[0], uuid[1], uuid[2], uuid[3], uuid[4], uuid[5], uuid[6], uuid[7],
            uuid[8], uuid[9], uuid[10], uuid[11], uuid[12], uuid[13], uuid[14], uuid[15]
        );
        return s;
    }

    string ReadrGUID (rGUID &g) {
        local string Guid = TranslateGUID(g.uuid);
        return Guid;
    }

    string ReadrGUIDComment(rGUID &g) { if (exists(g.GameObjectRef)) return g.GameObjectRef; return ""; }

    void WriterGuid (rGUID &g, string s) {
        local string out;
        local byte ii, offset, var;
        for (ii=0; ii<16; ii++) {
            if (ii==4 || ii== 6 || ii==8 || ii==10) 
                offset++;
            SScanf(SubStr(s, ii*2 + offset, 2), "%x", var);
            WriteByte(startof(g) + ii, var);
        }
    }

//functions for opening files:
string getRE2ext(wstring ext) {
	switch (ext) {
		case ".jcns": return ".11";
		case ".pfb": return ".16";
		case ".mdf2": case ".tex": case ".rcol": case ".jmap": return ".10";
		case ".efx": return ".1769669";
		case ".wcc": case ".wss": case ".ies": case ".uvar": case ".wss": case ".fbxskel": return ".2";
		case ".wel":   return ".11";
		case ".mesh": return ".1808312334";
		case ".fsmv2": case ".bhvt": case ".motfsm2": return ".30";
		case ".scn": return ".19";
		case ".motbank": case ".mov": return ".1";
		case ".chain": return ".21";
		case ".lprb": return ".3";
		case ".mmtr": return ".1808160001";
		case ".tml": case ".clip": case ".rbs": return ".27";
		case ".motlist": return ".85";
		case ".mcol": return ".3017";
		case ".cfil": case ".uvs":  return ".7";
		case ".mot": return ".65";
		case ".gui": return ".270020";
		case ".rmesh": return ".10008";
		case ".rtex": return ".4";
		case ".rbs": case ".rdd": return ".27019";
		case ".mcamlist": case ".msg": return ".13";
		default: return "";
	}
}

string getRE3ext(wstring ext) {
	switch (ext) {
		case ".mcol": return ".9018";
		case ".jcns": return ".12";
		case ".pfb": return ".17";
		case ".mdf2": return ".13";
		case ".tex": return ".190820018";
		case ".rcol": case ".jmap": return ".11";
		case ".lprb": return ".4";
		case ".efx": return ".2228526";
		case ".wcc": case ".wss": case ".ies": case ".uvar": case ".wss":  case ".user": return ".2";
		case ".wel":   return ".11";
		case ".mesh": return ".1902042334";
		case ".fsmv2": case ".bhvt": case ".tml": case ".clip": return ".34";
		case ".motfsm2": return ".36";
		case ".scn": return ".20";
		case ".mov": return ".1";
		case ".chain": return ".24";
		case ".fbxskel": case ".motbank":  return ".3";
		case ".mmtr": return ".1905100741";
		case ".rbs": return ".28";
		case ".motlist": return ".99";
		case ".cfil": case ".uvs":  return ".7";
		case ".mot": return ".78";
		case ".gui": return ".340020";
		case ".rmesh": return ".17008";
		case ".rtex": return ".4";
		case ".rdd": return ".28019";
		case ".mcamlist": return ".14";
		case ".msg": return ".15";
		default: return "";
	}
}

string getRE7ext(wstring ext) {
	switch (ext) {
        case ".uvar": case ".lprb": case ".rcol": case ".mcol": case ".wcc": case ".wss": case ".ies": return ".2";
		case ".pfb": return ".16";
		case ".mdf2": return ".6";
        case ".efx": return ".1179750";
        case ".tex": case ".jmap": case ".aimap": return ".8"; 
		case ".wel":   return ".10";
		case ".mesh": return ".32";
		case ".fsm": case ".motfsm": return ".17";
		case ".scn": case ".tml": return ".18";
		case ".motbank": return ".1";
        case ".mov": return ".1.x64";
		case ".chain": return ".5";
		case ".mmtr": return ".69";
		case ".motlist": return ".60";
		case ".cfil": return ".3";
        case ".uvs":  return ".5";
		case ".mot": return ".17";
		case ".gui": return ".180014";
		case ".rtex": return ".4";
		case ".mcamlist": return ".7";
        case ".msg": return ".12";
        case ".clo": return ".2016100701";
        case ".rbd": case ".rdl": return ".2016100700";
		default: return "";
	}
}

string getRE8ext(wstring ext) {
	switch (ext) {
		case ".mcol": return ".9018";
		case ".jcns": return ".16";
		case ".pfb": return ".17";
		case ".mdf2": return ".19";
		case ".tex": return ".30";
		case ".rcol": return ".18";
		case ".jmap": return ".17";
		case ".lprb": return ".4";
		case ".efx": return ".2228526";
		case ".wcc": case ".wss": case ".ies": case ".uvar": case ".wss":  case ".user": return ".2";
		case ".wel":   return ".11";
		case ".mesh": return ".2101050001";
		case ".bhvt": case ".tml": return ".34";
		case ".fsmv2": case ".clip": return ".40";
		case ".motfsm2": return ".42";
		case ".scn": return ".20";
		case ".mov": case ".finf": return ".1";
		case ".chain": return ".39";
		case ".fbxskel": case ".motbank":  return ".3";
		case ".mmtr": return ".1905100741";
		case ".rbs": return ".28";
		case ".motlist": return ".486";
		case ".cfil": case ".uvs":  return ".7";
		case ".mot": return ".458";
		case ".gui": return ".400023";
		case ".rmesh": return ".17008";
		case ".rtex": return ".5";
		case ".rdd": return ".28019";
		case ".mcamlist": return ".17";
		case ".msg": return ".15";
		case ".gpuc": return ".62";
		default: return "";
	}
}

string getDMCext(wstring ext) {
	switch (ext) {
		case ".jcns": return ".11";
		case ".pfb": return ".16";
		case ".mdf2": case ".rcol": case ".jmap": return ".10";
		case ".efx": return ".1769672";
		case ".wcc": case ".wss": case ".ies": case ".uvar": case ".wss": return ".2";
		case ".wel": case ".tex":  return ".11";
		case ".mesh": return ".1808282334";
		case ".fsmv2": case ".bhvt": return ".30";
		case ".scn": return ".19";
		case ".motbank": case ".mov": return ".1";
		case ".chain": return ".21";
		case ".fbxskel": case ".lprb": return ".3";
		case ".motfsm2": return ".31";
		case ".mmtr": return ".1808168797";
		case ".tml": case ".clip": case ".rbs": return ".27";
		case ".motlist": return ".85";
		case ".mcol": return ".3017";
		case ".cfil": case ".uvs":  return ".7";
		case ".mot": return ".65";
		case ".gui": return ".270020";
		case ".rmesh": return ".10008";
		case ".rtex": return ".4";
		case ".rbs": case ".rdd": return ".27019";
		case ".mcamlist": case ".msg": return ".13";
		default: return "";
	}
}

//convert a filepath string to Windows format:
string MakeBackslashes (wstring path, ubyte reverse) { //vfx
	local wstring localPath <hidden=true> = path;
    local wstring Char = "/", revChar = "\\";
    if (reverse) {
        Char = "\\\\";
        revChar = "/";
    }
	if (find(path, "@") != -1)
		localPath = StrDel(localPath, 0, 1);
	local uint index = find(localPath, Char);
	while (index != -1) {
		localPath = StrDel(localPath, index, sizeof(localPath) - index + 1) + revChar + SubStr(localPath, index + 1, -1);
		index = find(localPath, Char);
	} 
    return localPath;
}

void ReadRSZPath(wstring data) {
	local wstring localPath <hidden=true> = data;
    
	if (RSZVersion == "DMC5") {
		localPath = MakeBackslashes(localPath, 0) + getDMCext(FileNameGetExtension(localPath));
	} else if (RSZVersion == "RE3") {
		localPath = MakeBackslashes(localPath, 0) + getRE3ext(FileNameGetExtension(localPath));
	} else if (RSZVersion == "RE2") {
		localPath = MakeBackslashes(localPath, 0) + getRE2ext(FileNameGetExtension(localPath));
	} else if (RSZVersion == "RE7") {
		localPath = MakeBackslashes(localPath, 0) + getRE7ext(FileNameGetExtension(localPath));
	} else if (RSZVersion == "RE8" || RSZVersion == "MHRise") {
		localPath = MakeBackslashes(localPath, 0) + getRE8ext(FileNameGetExtension(localPath));
	} 

	if (exists(fullPath)) { 
	    fullPath = Local_Directory + localPath;
	    if (Local_Directory != extractedDir && FileExists(Local_Directory + localPath)) {
		    local uint existsInMod <hidden=false> = 1;
		    fullPath = Local_Directory + localPath;
	    }
	    if (extractedDir != "" && FileExists((extractedDir + localPath))) {
		    if (exists(existsInMod)) {
			    local uint existsInPak <hidden=false> = 1;
		    } else { 
			    local uint existsInPak <hidden=true> = 1; 
			    fullPath = extractedDir + localPath;
		    }
	    }
	    if (fullPath != "" && FileExists(fullPath)) {
		    FSkip(-1);
		    ubyte OpenFile <name="OpenFile", write=WriteOpenFile, read=ReadOpenFile, open=false>;
	    }
    }
}

    string ReadOpenFile (ubyte &in) { return "Input here to open File"; }
    
    void WriteOpenFile(ubyte &in, wstring s) { FileOpener(parentof(in).fullPath); }

int detectedGuid(uint tell) {
    local int zerosCount;
    for (o=0; o<16; o++) 
        zerosCount += (ReadUByte(FTell()+o) == 0);
    return zerosCount;
}

int detectedObject(uint tell) {
    if (tell+4 <= FileSize()) {
        local int test = ReadInt(tell);
        if (test < idx && test > 0 && (test > idx - 100 || exists(userDataPath)))
            return true;
    }
    return false;
}

void redetectObject() {
    if (!finished && broken ) {
        local int pos = FTell();
        while(FTell() <= FileSize() - 4) {
            if (detectedObject(FTell())) {
                SetForeColor(cYellow);
                Printf("Redetected object from %u to %u\n",  pos, FTell()); 
                break;
            } else FSkip(4);
        }
    }
}

void setAsBroken() {
    FSkip(-1);
    broken = true;
    SetForeColor(cNone);
    ubyte blank <hidden=true, bgcolor=cRed>;
}

void redetectFloat() {
    if (broken && FTell() + 4 <= FileSize() && (broken && !finished)) { 
        local int pos = FTell();
        while(FTell() <= FileSize() - 4 && detectedFloat(FTell()))
            FSkip(4);
        
        if (FTell() != pos && FTell() < pos + 16) {
            broken = FALSE;
            SetForeColor(cYellow);
            Printf("Redetected float from %u to %u\n",  pos, FTell()); 
        } else FSeek(pos);
    }
    if (!detectedFloat(FTell()) && ReadFloat(FTell()) != 0) {
        broken = TRUE;
        SetForeColor(cNone);
    }
}

void redetectGuid() {
    if (FTell() + 16 <= FileSize() && !finished && (detectedGuid(FTell()) >= 4)) { // && broken
        local int pos = FTell();
        //if (broken) 
        //    FSkip(-12);
        while(FTell() <= FileSize() - 16) {
            if (detectedGuid(FTell()) == 16 || (detectedGuid(FTell()) < 4 && (detectedGuid(FTell()) <= detectedGuid(FTell() + 8)))) {
                if (pos != FTell()) {
                    broken = FALSE;
                    SetForeColor(cYellow);
                    Printf("Redetected GUID from %u to %u\n",  pos, FTell()); 
                }
                break;
            } else FSkip(8);
        }
    }
}

int isValidString(uint tell) {
    local int alignedOffs = getAlignedOffset(tell, 4);
    if (alignedOffs + 4 >= FileSize())
        return false;
    local uint size = ReadUInt(alignedOffs);
    if (sizeof(ReadWString(alignedOffs+4)) == 0)
        return false;
    local wstring String = ReadWString(alignedOffs+4);
    return (alignedOffs+8 <= FileSize() && ReadUInt64(alignedOffs) == 1 || size == 0 || (size == sizeof(String)/2 && ReadUByte(alignedOffs+7 != 0)) );
}

void redetectStringBehind() {
    local int pos = FTell();
    if (detectedString(FTell())) {
        while (detectedString(FTell()) && ReadUInt(FTell()-4) != sizeof(ReadWString(FTell())) / 2) 
            FSkip(-2);
        FSkip(-4);
        if (pos == FTell() || !isValidString(FTell()) || (sizeof( ReadWString(FTell()+4)) + FTell() <= pos) ) {
            //Printf("Aborting string redetection from %u to %u\n",  pos, FTell()); 
            FSeek(pos);
            setAsBroken();
        } else if (FTell() < pos) {
            SetForeColor(cYellow);
            broken = FALSE;
            Printf("Redetected string from %u back to %u\n",  pos, FTell()); 
        }
    } 
}

void redetectString() {
    if (!broken && !isValidString(FTell()+4)) 
        return;
    if  (FTell() + 4 <= FileSize() && ( !finished && (broken || !isValidString(FTell()) ) ) ) {
        local int pos = FTell();
        while(FTell() <= FileSize() - 4 && FTell() - 24 < pos) {
            if (((detectedString(FTell()) && isValidString(FTell()-4)))) {
                FSkip(-4);
                break;
            } else uint skip <hidden=true>; //fgcolor=cRed,
        }
        if (FTell() - pos > 16 && broken) {
            FSeek(pos); //abort
        } else if (FTell() - pos > 8 && !broken) {
            FSeek(pos); //abort
        } else {
            SetForeColor(cYellow);
            broken = FALSE;
            Printf("Redetected string from %u to %u\n",  pos, FTell()); 
        }
    }
}

void ForceWriteString(uint tell, uint maxSize, wstring str) {
    OverwriteBytes(tell, maxSize, 0); 
    if (str != " " && str != "")
        WriteWString(tell, str); 
}

typedef ubyte Bool <read=ReadBOOL, write=WriteBOOL>;

    wstring ReadBOOL(Bool &b) {
        if (b)
            return "True";
        return "False";
    }
    
    void WriteBOOL(Bool &b, wstring s) {
        if (find(Lower(s), "true") != -1 || Atoi(s) >= 1)
            b = 1;
        else b = 0;
    }
    
//main typedef for RSZ chunks:
typedef struct(uint32 classHash, ubyte fieldIndex) {
    local uint32 classHash <hidden=true> = classHash;
    local ubyte fieldIndex <hidden=true> = fieldIndex;
    local string fieldName <hidden=true> = GetFieldName(classHash, fieldIndex);
    local string fieldDataType <hidden=true> = GetFieldTypeName(classHash, fieldIndex);
    local TypeIDs fieldType <hidden=true> = GetFieldType(classHash, fieldIndex);
    local ushort elementSize <hidden=true> = GetFieldSize(classHash, fieldIndex);
    local ubyte align <hidden=true> = GetFieldAlignment(classHash, fieldIndex);
    local ubyte isList <hidden=true> = GetFieldArrayState(classHash, fieldIndex);
    local ushort lvl <hidden=true>;
    if (exists(parentof(this).lvl)) 
        lvl = parentof(this).lvl;
    else 
        lvl = getLevel(FTell());

    if ((isList) && !exists(parentof(this).Count)) {
		setAlignment(4);
        if (FTell()+4 <= FileSize()) {
            uint Count;
		    setSize();
            if (Count > -1 && Count < FileSize()  && Count * elementSize <= FileSize() - FTell() ) {
                local uint c <hidden=true>, alignedOffs <hidden=true>;
                for (c=0; c<Count; c++) {
                    alignedOffs = getAlignedOffset(FTell(), align);
                    if (alignedOffs+elementSize <= FileSize()) {
                        FSeek(alignedOffs);
                        if (Count == 1 && (fieldType == Object_tid || (fieldType == Data_tid && detectedObject(FTell())))) {
			                struct RSZVariable var(classHash, fieldIndex) <open=true>;
                            checkUseSpacers();
                        } else
                            struct RSZVariable var(classHash, fieldIndex);
                    } else {
                        setAsBroken();
                        break;    
                    }
                }
            } else setAsBroken();
        }
	} else {
        setAlignment(align);
		switch (fieldType) {
			case Bool_tid:
				if (FTell()+1 <= FileSize())
				    Bool data;
				break;
			case Color_tid:
                if (FTell()+4 <= FileSize())
				    ubyte data <name="ubyte R">, data <name="ubyte G">, data <name="ubyte B">, data <name="ubyte A">;
				break;
			case F32_tid:
				fieldDataType = "Float";
				if (FTell()+4 <= FileSize())
				    float data;
				break;
			case F64_tid:
				fieldDataType = "Double";
				if (FTell()+8 <= FileSize())
				    double data;
				break;
            case PlaneXZ_tid:
				if (FTell()+8 <= FileSize())
				    float data <name="float x">, data <name="float z">;
				break;
			case Float2_tid:
			case Point_tid:
            case Segment_tid:
				if (FTell()+8 <= FileSize())
				    float data <name="float x">, data <name="float y">;
				break;
			case Float3_tid:
				if (FTell()+12 <= FileSize())
				    float data <name="float x">, data <name="float y">, data <name="float z">;
				break;
			case Quaternion_tid:
			case Float4_tid:
				if (FTell()+16 <= FileSize())
				    float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
				break;
			case GameObjectRef_tid:
            case Guid_tid:
            case Uri_tid:
				if (FTell()+16 <= FileSize())
				    rGUID Guid;
                break;
            case DateTime_tid:
                int64 data;
                break;
            case OBB_tid:
            case AABB_tid:
            case Capsule_tid:
            case LineSegment_tid:
			case Mat4_tid:
				if (FTell()+32 <= FileSize()) {
				    float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
				    float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                    if (fieldType == Capsule_tid) {
                        if (FTell()+4 <= FileSize())
				            float data <name="float r">;
                    } else if (fieldType != AABB_tid) {
					    if (FTell()+32 <= FileSize()) {
				            float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
					        float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                            if (fieldType == OBB_tid && FTell()+16 <= FileSize())
                                float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                        } 
                    }
                }
				break;
			case UserData_tid:
            case Object_tid:
                if (FTell()+4 <= FileSize()) {
                    int ObjectIndex;
                    //FSkip(-4); int data <hidden=true>;
                }
                if (fieldType == UserData_tid && exists(ObjectIndex) && ObjectIndex > -1 && RSZVersion != "RE7") {
                    if ((RSZVersion == "DMC5" || RSZVersion == "RE2") && exists(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx)) {
                        if (RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx == -1) {
                            Printf("Broken UserData at %i\n", FTell());
                        } else if (exists(RSZFile[lvl].RSZUserDataInfos.userDataInfo[RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx].RSZOffset_Absolute.OffsetAbs)) {
                            FSeek(RSZFile[lvl].RSZUserDataInfos.userDataInfo[RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx].RSZOffset_Absolute.OffsetAbs);
                            struct RSZMagic UserData <open=true, size=56, fgcolor=cNone>;
                            FSeek(startof(ObjectIndex)+4);
                            checkUseSpacers();
                            break;
                        } 
                    } else if (exists(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx)) {// RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx
                        FSkip(-1);
                        struct StringRead path ( (startof(RSZFile[lvl].RSZUserDataInfos.userDataInfo[RSZFile[lvl].Data.RawData.RSZ[ObjectIndex].userDataIdx])+8), startof(RSZFile[lvl].RSZHeader), 0);
                        break;
                    } 
                } else if (exists(ObjectIndex) && ObjectIndex > 0 && exists(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex])) { //fieldType == Object_tid &&  
					FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex])); 
					struct RSZInstance RSZ <open=true, size=SizeRSZInstance>;
                    checkUseSpacers();
					FSeek(startof(ObjectIndex)+4);
				}
				break;
			case Range_tid:
                if (FTell()+8 <= FileSize())
				    float data <name="float R">, data <name="float S">;
				break;
			case RangeI_tid:
                if (FTell()+8 <= FileSize())
				    int data <name="int R">, data <name="int S">;
				break;
			case RuntimeType_tid:
                if (FTell()+4 <= FileSize()) {
				    uint size;
                    if (size && FTell() + size <= FileSize())
					    char data[size];
                }
				break;
			case S16_tid:
                if (FTell()+2 <= FileSize())
				    short data;
				break;
			case S32_tid:
				fieldDataType = "Int";
				if (FTell()+4 <= FileSize())
				    int data;
				break;
			case Enum_tid:
				//fieldDataType = "Enum";
				if (FTell()+4 <= FileSize())
				    int data;
				break;
			case S64_tid:
				fieldDataType = "Int64";
				if (FTell()+8 <= FileSize())
				    int64 data;
				break;
			case S8_tid:
				fieldDataType = "Byte";
				if (FTell()+1 <= FileSize())
				    byte data;
				break;
			case Size_tid:
				fieldDataType = "Size";
				if (FTell()+4 <= FileSize())
				    uint data;
				break;
			case U16_tid:
				fieldDataType = "UShort";
				if (FTell()+2 <= FileSize())
				    ushort data;
				break;
			case U32_tid:
				fieldDataType = "UInt";
				if (FTell()+4 <= FileSize())
				    uint data;
				break;
			case U64_tid:
				fieldDataType = "UInt64";
				if (FTell()+8 <= FileSize())
				    uint64 data;
				break;
			case U8_tid:
				fieldDataType = "UByte";
				if (FTell()+1 <= FileSize())
				    ubyte data;
				break;
			case Vec2_tid:
				if (FTell()+16 <= FileSize()) {
				    float data <name="float x">, data <name="float y">;
				    float data <hidden=true>, data <hidden=true>; //FSkip(8);
                }
				break;
			case Vec3_tid:
                if (FTell()+16 <= FileSize()) {
				    float data <name="float x">, data <name="float y">, data <name="float z">;
				    float data <hidden=true>; //FSkip(4);
                }
				break;
			case Vec4_tid:
                if (FTell()+16 <= FileSize()) {
				    float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                }
				break;
			case Int2_tid:
                if (FTell()+8 <= FileSize())
				    int32 data <name="int x">, data <name="int y">;
                break;
            case Int3_tid:
                if (FTell()+12 <= FileSize())
				    int32 data <name="int x">, data <name="int y">, data <name="int z">;
                break;  
            case Uint3_tid:
                if (FTell()+12 <= FileSize())
				    uint32 data <name="uint x">, data <name="uint y">, data <name="uint z">;
                break;
            case Data_tid:
            case ukn_type: 
                if (find((wstring)fieldDataType, "tring") == -1) { //if NOT a string:
                    if (elementSize == 1 ) { 
                        fieldDataType = "Byte";
                        if (FTell()+1 <= FileSize())
				            byte data;
                    } else if (elementSize == 2) {
                        fieldDataType = "Int16";
                        if (FTell()+2 <= FileSize())
				            short data;
                    } else if (elementSize == 4) {
                        fieldDataType = "Data";
                        if (FTell()+4 <= FileSize())
                            if (ReadInt(FTell()) != 0 && detectedFloat(FTell()) ) { //&& ReadUByte(FTell()+3) != 255
                                if (FTell()+4 <= FileSize()) {
				                    float data;
                                    FSkip(-4);
                                    int data_As_Int;
                                }
                            } else if (detectedObject(FTell())){
                                fieldDataType = "Data (Object?)";
                                if (FTell()+4 <= FileSize()) {
				                    int ObjectIndex <name="int data (ObjectIndex?)">;
                                    //FSkip(-4); int data <hidden=true>;
					                if (exists(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex])) {
						                FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[ObjectIndex]));
                                        struct RSZInstance RSZ <size=SizeRSZInstance, open=true>;
                                        checkUseSpacers();
						                FSeek(startof(ObjectIndex)+4);
					                }
                                }
                            } else {
                                if (FTell()+4 <= FileSize()) {
				                    int data;
                                    FSkip(-4);
                                    float data_As_Float;
                                }
                            }
                    } else if (elementSize == 8) {
                        if (detectedFloat(FTell()) && detectedFloat(FTell()+4)) {
                            if (FTell()+8 <= FileSize())
				                float data <name="float x">, data <name="float y">;
                        } else {
                            fieldDataType = "Int64";
                            if (FTell()+8 <= FileSize())
				                int64 data;
                        }
                    } else if (elementSize == 16) {
                        if (align == 8) {
                            fieldDataType = "Guid";
                            fieldType = Guid_tid;
                            if (FTell()+16 <= FileSize())
				                rGUID Guid;
                        } else {
                            fieldDataType = "Vec4";
                            if (FTell()+16 <= FileSize())
				                float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                        }
                    } else if (elementSize == 64 || elementSize == 80) {
                        fieldDataType = "Mat4";
                        if (FTell()+4 <= FileSize()) {
                            float data <name="float x1">, data <name="float y1">, data <name="float z1">, data <name="float w1">;
                            float data <name="float x2">, data <name="float y2">, data <name="float z2">, data <name="float w2">;
                            float data <name="float x3">, data <name="float y3">, data <name="float z3">, data <name="float w3">;
                            float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                            if (elementSize == 80) {
                                fieldDataType = "OBB";
                                if (FTell()+16 <= FileSize())
				                    float data <name="float x">, data <name="float y">, data <name="float z">, data <name="float w">;
                            }
                        }
                    } else {
                        if (FTell()+elementSize <= FileSize())
                            if (elementSize % 4 == 0) {
                                local ubyte counter <hidden=true>;
                                while(counter < (uint)(elementSize / 4)) {
                                    if (detectedFloat(FTell()))
                                        float data;
                                    else int data;
                                    counter++;
                                }
                            }
				            else ubyte data[elementSize];
                    }
                    break;
                } //if it IS a string, don't break and continue on:
            
			case Resource_tid:
			case String_tid:
                fieldType = String_tid;
				fieldDataType = "String";
                FSeek(getAlignedOffset(FTell(), 4));
                if (!isList) {
                    redetectStringBehind();
				    FSeek(getAlignedOffset(FTell(), 4)); 
                    if (isValidString(FTell()) && ReadUInt(FTell()) != 0)
                        broken=false;
                    else redetectString();
                }
                if (FTell() + 4 <= FileSize()) {
				    uint size;
                    if (size && FTell() + size * 2 <= FileSize() )
					    wchar_t data[size] <open=suppress>;
                    if (size > 0 && !exists(data) && !detectedFloat(FTell()-4)) 
                        setAsBroken();
                    local ubyte isString <hidden=true> = TRUE;
                    if (!isValidString(startof(size)) && (size > 128) || (broken && size > 64))
                        FSeek(startof(size)+1);
                } else FSeek(startof(this));
				break;
            
			default:
				Printf("%u Unknown type %s in class \"%s\" (Hash: 0x%08X) field number %d returned TypeID = \"%d\" ListFlag = \"%d\"\r\n", 
                FTell(), EnumToString(fieldType), GetRSZClassName(classHash), classHash, fieldIndex, fieldType, isList);
                if (elementSize % 4 == 0)
                    float data[elementSize/4];
                else
                    ubyte data[elementSize];
				break;
		}

        if (!finished) {
            FSkip(-1);
            ubyte FieldNamer <read=ReadVariableNamer, write=WriteVariableName>;
        }

        if (elementSize > 16)
            FSeek(startof(Alignment.varStart) + elementSize);
        else if (elementSize == 4 && exists(data) && startof(data)+4 <= FileSize() && ReadInt(startof(data)) <= 512)
            enums();


    }
    setSize();
    
    if (title == "" && exists(this.size) && exists(this.data) && size > 1 ) {
        title = (wstring)data;
    } else if (secondTitle == "") {
        if (exists(this.UserData)) {
            secondTitle = ReadRSZMagic(this.UserData);
        } else if (exists(this.path.String)) {
            secondTitle = this.path.String;
        } else if (exists(this.Guid) && ReadUInt64(startof(Guid)) != 0) {
            secondTitle = ReadrGUID(Guid);
        } else if (exists(this.RSZ) && this.ObjectIndex > 2) {
            if (!isList || parentof(this).Count == 1) {
                secondTitle = ReadRSZInstance(this.RSZ) + " ";
                if (secondTitle == " " || secondTitle == "False " || secondTitle == "True " || Atoi(secondTitle) != 0) 
                    secondTitle = "";
                else secondTitle = StrDel(secondTitle, sizeof(secondTitle)-1, 1);
            } else if (exists(parentof(this).var[0].RSZ) && parentof(this).Count > 1 && exists(parentof(this).var[parentof(this).Count-2])) {
                SPrintf(s, "%s - [%i]", ReadRSZInstanceName(parentof(this).var[0].RSZ), this.ObjectIndex) ;
                secondTitle = s;
            }
        }
    }
    
    if (fieldDataType == "String" && exists(data) && find((wstring)data, "/") != -1 && FileNameGetExtension((wstring)data) != ".json") {
        local wstring fullPath <hidden=true>;
        ReadRSZPath((wstring)data);
    }
    if (FTell() <= startof(this)) {
        Printf("Empty struct %s\n", ReadRSZInstanceName(parentof(this))); 
        FSeek(startof(this));
    }
} RSZVariable <optimize=false, name=ReadRSZVariableName, read=ReadRSZVariable, write=WriteRSZVariable, comment=ReadRSZVariableComment>;

    string ReadRSZVariableComment(RSZVariable &r) { if (exists(r.data.GameObjectRef)) return r.data.GameObjectRef; return ""; }
    
    string ReadRSZVariableName(RSZVariable &r) { 
        local string s; 
        if (r.isList) {
            if ((exists(r.var[0]) && exists(r.var[0].ObjectIndex) && r.var[0].ObjectIndex != 0) || exists(r.var[0].UserData) ) {
                if (r.fieldDataType == "Data") {
                    SPrintf(s, "List (Object?) *%s", r.fieldName); // %s[%u] //, RSZFile[r.lvl].Data.RawData.RSZ[r.var[0].ObjectIndex].name, r.var[0].ObjectIndex
                } else { SPrintf(s, "List (%s) *%s", r.fieldDataType, r.fieldName); }
            } else if (exists(r.RSZ)) {
                s = ReadRSZInstanceName(r.RSZ);
                if (sizeof(s) + sizeof(r.fieldName) + 1 < 32 )
                    return s + " " + r.fieldName;
                return "List (Object) " + r.fieldName;
            } else 
                { s = "List" + " (" + r.fieldDataType + ") " + r.fieldName; }
        } else if (exists(r.ObjectIndex) && exists(parentof(r).fieldDataType) && parentof(r).fieldDataType == "List") {
            SPrintf(s, "%s[%u]", RSZFile[r.lvl].Data.RawData.RSZ[r.ObjectIndex].name, r.ObjectIndex);
        } else if (r.fieldDataType != "") {
            if ((exists(r.RSZ) && r.ObjectIndex != 0) || exists(r.UserData) )
                s = r.fieldDataType + " *" + r.fieldName; 
            else if (r.fieldDataType + " " + r.fieldName == "Byte v0")
                s = "Byte v0 (isEnabled?)";
            else s = r.fieldDataType + " " + r.fieldName;  
        } else s = r.fieldName; 
        return s;
    }

    wstring ReadRSZVariable(RSZVariable &r) {
        local string s;
        if (exists(r.UserData)) {
            return ReadRSZMagic(r.UserData);
        } else if (exists(r.var)) {
            if (exists(r.var[1].RSZ) && exists(r.var[r.Count-1])) {
                SPrintf(s, "%s - [%i]", ReadRSZInstanceName(r.var[0].RSZ), r.var[r.Count-1].ObjectIndex); 
                return s;
            } 
            return ReadRSZVariable(r.var[0]);
        } else if (exists(r.RSZ) && r.ObjectIndex > 0) {
            return ReadRSZInstance(r.RSZ);
        } else 
            switch (r.fieldType) {
                case UserData_tid:
                    if (exists(r.path.String))
                        s = r.path.String;
                    break;
                case Bool_tid:
                    if (exists(r.data))
                        s = ReadBOOL(r.data);
                    break;
		        case S8_tid:
		        case S16_tid:
		        case S32_tid:
		        case S64_tid:
		        case Size_tid:
                case U8_tid:
		        case U16_tid:
		        case U32_tid:
		        case U64_tid:
			    case Enum_tid:
                    if (exists(r.data))
                        SPrintf(s, "%Li", r.data);
                    break;
                case F32_tid:
                    if (exists(r.data))
                        SPrintf(s, "%f", r.data);
                    break;
		        case Resource_tid:
                case String_tid:
                    if (exists(r.data))
                        return r.data;
                    break;
                case Float2_tid:
                case Vec2_tid:
                case Point_tid:
                case Range_tid:
                    if (exists(r.data))
                        SPrintf(s, "[%g, %g]", r.data[0], r.data[1]);
                    break;
                case Vec3_tid:
                case Float3_tid:
                case Int3_tid:
                    if (exists(r.data))
                        SPrintf(s, "[%g, %g, %g]", r.data[0], r.data[1], r.data[2]);
                    break;
                case Color_tid:
                case Vec4_tid:
                case Mat4_tid:
                case Float4_tid:
				case Quaternion_tid:
                    if (exists(r.data))
                        SPrintf(s, "[%g, %g, %g, %g]", r.data[0], r.data[1], r.data[2], r.data[3]);
                    break;
                case Guid_tid:
                case GameObjectRef_tid:
                case Uri_tid:
                    if (exists(r.data))
                        s = ReadrGUID(r.data);
                    if (exists(r.Guid))
                        s = ReadrGUID(r.Guid);
                    break;
                case AABB_tid:
                    if (exists(r.data))
                        SPrintf(s, "[%g, %g, %g %g] [%g, %g, %g %g]", r.data[0], r.data[1], r.data[2], r.data[3],  r.data[4],  r.data[5],  r.data[6], r.data[7]);
                    break;
                case Mat4_tid:
                    if (exists(r.data))
                        SPrintf(s, "[%g, %g, %g %g] [%g, %g, %g %g] [%g, %g, %g %g] [%g, %g, %g %g]", r.data[0], r.data[1], r.data[2], r.data[3], r.data[4], r.data[5], r.data[6], r.data[7], r.data[8], r.data[9], r.data[10], r.data[11], r.data[12], r.data[13], r.data[14], r.data[15]);
                    break;
                case ukn_type:
                case Data_tid:
                    if (exists(r.data) && r.elementSize == 1 ) { //|| r.fieldOrgTypeName == "Data1A1"
                        if (r.data == 1) {
                            s = "True";
                        } else if (r.data == 0) {
                            s = "False";
                        } else 
                            SPrintf(s, "%i", r.data);
                    } else if (exists(r.data) && r.elementSize == 4) {
                        if (exists(r.data_As_Int))
                            SPrintf(s, "%f", r.data);
                        else if (Abs(r.data) > 1000000) 
                            SPrintf(s, "%X", r.data);    
                        else 
                            SPrintf(s, "%i", r.data);
                    } else if (exists(r.data) && r.elementSize == 8) {
                        if (exists(r.data[1]) && (detectedFloat(FTell()) || detectedFloat(FTell()+4)))
                            SPrintf(s, "[%g, %g]", r.data[0], r.data[1]);
                        else
                            SPrintf(s, "%Li", r.data);
                    } else if (r.elementSize == 16) {
                        if (exists(r.Guid))
                            s = ReadrGUID(r.Guid);
                        else if (exists(r.data[3]))
                            SPrintf(s, "[%g, %g, %g, %g]", r.data[0], r.data[1], r.data[2], r.data[3]);
                    } else if (exists(r.data) && r.elementSize == 64) {
                        SPrintf(s, "[%g, %g, %g %g] [%g, %g, %g %g] [%g, %g, %g %g] [%g, %g, %g %g]", r.data[0], r.data[1], r.data[2], r.data[3], r.data[4], 
                            r.data[5], r.data[6], r.data[7], r.data[8], r.data[9], r.data[10], r.data[11], r.data[12], r.data[13], r.data[14], r.data[15]);
                    }
                    break;
                default:
                    break;
            }
        return s;
    }
    
    void WriteRSZString(RSZVariable &r, wstring s) { 
        local int oldDataSz;
        local wstring str;
        
        if (exists(r.data)) 
            wstring oldData = r.data;
        else
            wstring oldData = "";
        
        if (find(s, "\\\\") != -1) { //Formats a real filepath to RE Engine format
            if (find(s, "natives\\\\") != -1)
                s = WStrDel(s, 0, find(s, "natives\\\\") + 12);
            if (find(s, "[.]\\d") != -1)
                s = WStrDel(s, find(s, "[.]\\d"), sizeof(s) - find(s, "[.]\\d"));
            s = MakeBackslashes(s, true);
            WStrcpy(str,WStrDel(s, WStrlen(s), sizeof(s) - WStrlen(s)));
        } else 
            WStrcpy(str,s);
        
        if (exists(r.data)) {
            oldDataSz = sizeof(r.data);
            local int temp;
            if (exists(Header.resourceCount))
                for (o=0; o<Header.resourceCount; o++) {
                    if (exists(ResourceInfos.ResourceInfo[o].pathStr) && ResourceInfos.ResourceInfo[o].pathStr.String == oldData) {
                        while (!FEof() && ReadByte(startof(ResourceInfos.ResourceInfo[o].pathStr.String)+oldDataSz+temp) == 0)
                            temp++;
                        oldDataSz += temp;
                    } else if (exists(ResourceInfos.ResourceInfo[o].path) && ResourceInfos.ResourceInfo[o].path == oldData) {
                        while (!FEof() && ReadByte(startof(ResourceInfos.ResourceInfo[o].path)+oldDataSz+temp) == 0)
                            temp++;
                        oldDataSz += temp;
                    }
                } 
        }
        Printf("Sizeof(input)=%i, sizeof(oldData)=%i \n", sizeof(str)-2, oldDataSz);
        local int sizeToInsert = (sizeof(str)-2) - oldDataSz;
        
        if (sizeToInsert > 0) {
            if (exists(r.data))
                Printf("Size to Insert: %i\nr.data: %s\ns.data: %s\n", sizeToInsert, r.data, str);
            
            while (sizeToInsert % 16 != 0)
                sizeToInsert++;
            Printf("Size to Insert (padded): %i\n", sizeToInsert);
            if (RSZVersion == "RE2" || RSZVersion == "DMC5") {
                local int ii;
                while (exists(RSZFile[ii])) {
                    if (startof(r.size)+4 > startof(RSZFile[ii].RSZHeader) && startof(r.size)+4 < startof(RSZFile[ii].Data) + sizeof(RSZFile[ii].Data) && startof(RSZFile[r.lvl].RSZHeader) != startof(RSZFile[ii].RSZHeader)) {
                        Printf("%i %i %i\n", startof(r.size)+4, startof(RSZFile[ii].RSZHeader), startof(RSZFile[ii].Data) + sizeof(RSZFile[ii].Data) );
                        RSZFile[ii].RSZHeader.dataOffset += sizeToInsert;
                    }
                    ii++;
                }
            }
            InsertBytes(startof(r.size)+4, sizeToInsert, 0); 
        } else 
            sizeToInsert = 0;
        
        ForceWriteString(startof(r.size)+4, sizeToInsert+oldDataSz, str); 
        r.size = (sizeToInsert+oldDataSz)/2;
        
        if (find(oldData, "/") != -1) {
            local byte resourceInfosIncreased = FALSE;
            local int changeOffs, h;
            for (h=0; h<Header.resourceCount; h++) {
                if (ResourceInfos.ResourceInfo[h].pathStr.String == oldData) {
                    Printf("Found old ResourceInfo\n");
                    resourceInfosIncreased = TRUE;
                    break;
                }
            }
            if (resourceInfosIncreased == TRUE ) { // if not PFB //&& exists(Header.userdataCount)
                local int paddingBytes;
                while((RSZFile[r.lvl].RSZHeader.dataOffset + sizeToInsert + paddingBytes) % 16 != RSZFile[r.lvl].RSZHeader.dataOffset % 16)
                    paddingBytes++;
                
                for (h=0; h<Header.resourceCount; h++) {
                    
                    if (ResourceInfos.ResourceInfo[h].pathStr.String == oldData) {
                        
                        changeOffs = startof(ResourceInfos.ResourceInfo[h].pathStr.String);
                        //DeleteBytes(startof(ResourceInfos.ResourceInfo[h].pathStr.String), sizeof(ResourceInfos.ResourceInfo[h].pathStr.String));
                        if (sizeToInsert > 0) {
                            InsertBytes(startof(ResourceInfos.ResourceInfo[h].pathStr.String) + sizeof(ResourceInfos.ResourceInfo[h].pathStr.String), sizeToInsert);
                        }
                        ForceWriteString(startof(ResourceInfos.ResourceInfo[h].pathStr.String), oldDataSz, str);
                    }
                    if (exists(ResourceInfos.ResourceInfo[h].pathStr.strOffset) && changeOffs > 0 && changeOffs < startof(ResourceInfos.ResourceInfo[h].pathStr.String))
                        ResourceInfos.ResourceInfo[h].pathStr.strOffset += sizeToInsert;
                }
                if (exists(PrefabInfos) && changeOffs > 0 && sizeToInsert) {
                    for (h=0; h<Header.prefabCount; h++) 
                        PrefabInfos.PrefabInfo[h].id += sizeToInsert;
                }
                if (paddingBytes)
                    InsertBytes(RSZFile[r.lvl].RSZHeader.dataOffset + startof(RSZFile[r.lvl].RSZHeader), paddingBytes, 0);
                RSZFile[r.lvl].RSZHeader.dataOffset += paddingBytes;
            }
            
        }
        if (sizeToInsert > 0) {
            if (exists(resourceInfosIncreased) && resourceInfosIncreased == TRUE)
                Header.dataOffset += sizeToInsert;
            if (exists(UserDataInfos)) {
                for (h=0; h<Header.userdataCount; h++)
                    UserDataInfos.userDataInfo[h].pathOffset.strOffset += sizeToInsert;
                for (h=0; h<Header.prefabCount; h++)
                    PrefabInfos.PrefabInfo[h].id += sizeToInsert;
            }
            MessageBox( idOk, "Insert Data", "Press F5 to refresh the template and fix template results");
        } 
    }

    void WriteRSZVariable(RSZVariable &r, wstring s) {
        if (exists(r.fullPath) && r.fullPath != "" && s == " ") {
            FileOpener(r.fullPath);
        } else {
            local int pos = startof(r.Alignment.varStart);
            switch (r.fieldType) {
                case Bool_tid:
                    WriteBOOL(r.data, s); break;
		        case S16_tid:
                    WriteShort(pos, Atoi(s)); break;
		        case Object_tid:
		        case UserData_tid:
                    if (s == " " && exists(r.RSZ))
                        WriteRSZInstance(r.RSZ, s);
                    else if (s == " " && exists(r.path))
                        WriteStringRead(r.path, (string)s);
                    else
                        WriteInt(pos, Atoi(s)); 
                    break;
                case Size_tid:
		        case S32_tid:
                    WriteInt(pos, Atoi(s)); break;
		        case S64_tid:
                    WriteInt64(pos, Atoi(s)); break;
		        case S8_tid:
                    WriteByte(pos, Atoi(s)); break;
		        case U16_tid:
                    WriteUShort(pos, Atoi(s)); break;
		        case U32_tid:
                    WriteUInt(pos, Atoi(s)); break;
		        case U64_tid:
                    WriteUInt64(pos, Atoi(s)); break;
                case F32_tid:
                    WriteFloat(pos, Atof(s)); break;
                case String_tid:
                case Resource_tid:
                    WriteRSZString(r, s);
                    break;
                case Vec2_tid:
                case Range_tid:
                case Float2_tid:
                case Point_tid:
                    WriteRSZArray(r, s, 2, 4);
                    break;
                case Vec3_tid:
                case Float3_tid:
                    WriteRSZArray(r, s, 3, 4);
                    break;
                case Vec4_tid:
                case Float4_tid:
                case Quaternion_tid:
                    WriteRSZArray(r, s, 4, 4);
                    break;
                case Color_tid:
                    WriteRSZArray(r, s, 4, 1);
                    break;
                case AABB_tid:
                    WriteRSZArray(r, s, 8, 4);
                    break;
                case Mat4_tid:
                    WriteRSZArray(r, s, 16, 4);
                    break;
                case Guid_tid:
                case GameObjectRef_tid:
                case Uri_tid:
                    if (exists(r.data))
                        WriterGuid(r.data, (string)s);
                    else if (exists(r.Guid))
                        WriterGuid(r.Guid, (string)s);
                    break;
                case Data_tid:
                case ukn_type:
                    s = Lower(s);
                    if (exists(r.data) && r.elementSize == 1) {
                        if (s == "true") {
                            r.data = 1;
                        } else if (s == "false") {
                            r.data = 0;
                        } else r.data = Atoi(s);
                    } else if (exists(r.ObjectIndex) || exists(r.data_As_Int) || exists(r.data_As_Float)) {
                        
                        if (exists(r.data_As_Int)) {
                            WriteFloat(startof(r.Alignment.varStart), Atof(s));
                        } else {
                            WriteInt(startof(r.Alignment.varStart), Atoi(s));
                        }
                    } else if (exists(r.size) || find((wstring)r.fieldDataType, "tring") != -1) {
        	            WriteRSZString(r, s);
                    } else if (r.fieldDataType == "Vec4") {
                        WriteRSZArray(r, s, 4, 4);
                    }
                    break;
                default:
                    break;
            }
        }
    }

    void WriteRSZArray(RSZVariable &r, wstring array, uint count, uint elementSize) {
        local uint q; 
        local float outArr[count];
        local string fmtString;
        local string FMT = "%g";
        if (elementSize == 1)
            FMT = "%i";
        if (array[0] == 91)
            fmtString += "[";
        if (find(array, ",") == -1) {
            for (q=0; q<count-1; q++)
                fmtString += FMT + " ";
            fmtString += FMT;
        } else {
            for (q=0; q<count-1; q++)
                fmtString += FMT + ", ";
            fmtString += FMT;
        }
        if (count == 2)
            SScanf(array, fmtString, r.data[0], r.data[1]);
        else if (count == 3)
            SScanf(array, fmtString, r.data[0], r.data[1], r.data[2]);
        else if (count == 4)
            SScanf(array, fmtString, r.data[0], r.data[1], r.data[2], r.data[3]);
        else if (count == 8)
            SScanf(array, fmtString, r.data[0], r.data[1], r.data[2],  r.data[3], r.data[4], r.data[5], r.data[6], r.data[7]);
        else if (count == 16)
            SScanf(array, fmtString, r.data[0], r.data[1], r.data[2],  r.data[3], r.data[4], r.data[5], r.data[6], r.data[7], r.data[8], r.data[9], r.data[10],  r.data[11], r.data[12], r.data[13], r.data[14], r.data[15]);
    }

    string ReadVariableNamer(ubyte &v) { return "      [Input a Name or Datatype + Name to name this field]      "; }
    
    void WriteVariableName(ubyte &v, string newString) {
        local short fileNum = GetFileNum();
        local string locPath = FileNameGetPath(GetTemplateFileName());
        local string hashToFind; SPrintf(hashToFind, "%x", parentof(v).classHash);
        local string newFieldName = newString;
        local string newFieldType;
        if (findS(newString, " ") != -1) {
            newFieldType = SubStr(newString, 0, findS(newString, " "));
            newFieldName = SubStr(newString, findS(newString, " ")+1, -1);
            switch (newFieldType) {
                case "Byte": newFieldType = "S8"; break;
                case "UByte": newFieldType = "U8"; break;
                case "Int": newFieldType = "S32"; break;
                case "UInt": newFieldType = "U32"; break;
                case "Int64": newFieldType = "S64"; break;
                case "UInt64": newFieldType = "U64"; break;
                case "Float": newFieldType = "F32"; break;
                default: break;
            }
        }
        
        FileOpen(JsonPath);
        FileSelect(FindOpenFile(JsonPath));
        local int hashOffset = FindFirst(hashToFind, 0);
        local int varOffset = FindFirst(parentof(v).fieldName, 1, 0, 0, 0, 1, hashOffset, FindFirst("]", 1, 0, 0, 0, 1, hashOffset) - hashOffset);
        if (hashOffset > -1) {
            ReplaceAll(parentof(v).fieldName, newFieldName, 1, 1, 0, 0, 1, varOffset, sizeof(parentof(v).fieldName));
            if (!IsInitialized())
                ParseJson(JsonPath);
            if (newFieldType != "")
                ReplaceAll(GetFieldTypeName(parentof(v).classHash, parentof(v).fieldIndex), newFieldType, 1, 1, 0, 0, 1, varOffset, FindFirst("}", 1, 0, 0, 0, 1, varOffset) - varOffset); 
            SetCursorPos(varOffset);
            if (MessageBox( idOk | idCancel, "Change JSON", "Field will be changed to %s %s", newFieldType, newFieldName) == idOk) {
                FileSave();
                //FileClose();
                if (RSZVersion != "RE7" && MessageBox( idYes | idNo, "Change JSON", "Find and change this field in the other JSON dumps too?") == idYes) {
                    local string tempJSONPath;
                    for (j=0; j<5; j++) {
                        switch (j) {
                            case 0: tempJSONPath=Lower(locPath + "rszre2.json"); break;
                            case 1: tempJSONPath=Lower(locPath + "rszre3.json"); break;
                            case 2: tempJSONPath=Lower(locPath + "rszre8.json"); break;
                            case 3: tempJSONPath=Lower(locPath + "rszdmc5.json"); break;
                            default: tempJSONPath=Lower(locPath + "rszmhrise.json"); break;
                        }
                        if (tempJSONPath == JsonPath) 
                            continue;
                        FileOpen(tempJSONPath);
                        FileSelect(FindOpenFile(tempJSONPath));
                        hashOffset = FindFirst(hashToFind, 0);
                        varOffset = FindFirst(parentof(v).fieldName, 1, 0, 0, 0, 1, hashOffset, FindFirst("]", 1, 0, 0, 0, 1, hashOffset) - hashOffset);
                        if (varOffset > -1) {
                            ReplaceAll(parentof(v).fieldName, newFieldName, 1, 1, 0, 0, 1, varOffset, sizeof(parentof(v).fieldName));
                            if (newFieldType != "")
                                ReplaceAll(GetFieldTypeName(parentof(v).classHash, parentof(v).fieldIndex), newFieldType, 1, 1, 0, 0, 1, varOffset, FindFirst("}", 1, 0, 0, 0, 1, varOffset) - varOffset); 
                            SetCursorPos(varOffset);
                            if (MessageBox( idOk | idCancel, "Change JSON", "Field will be changed to %s %s", newFieldType, newFieldName) == idOk)
                                FileSave();
                            //FileClose();
                        } else {
                            Printf("Field '%s' not found in %s!\n", parentof(v).fieldName, tempJSONPath);
                            FileClose();
                        }
                    }
                }
            }
        } else {
            Printf("Field '%s' not found in %s!\n", parentof(v).fieldName, JsonPath);
            FileClose();
        }
        FileSelect(fileNum);
    }

typedef struct {
    //find out if on-demand:
    local ubyte isOnDemand <hidden=true> = (sizeof(this) != 0);
    
    //Get containing RSZMagic index:
    if (exists(parentof(this).lvl))  
        local ushort lvl <hidden=true> = parentof(this).lvl;
    else 
        local ushort lvl <hidden=true> = getLevel(FTell());
    
    //Get Instance index:
    local int idx <hidden=true>;
    if (isOnDemand && exists(ObjectIndex)) {
        idx = ObjectIndex;
    } else if (exists(RSZIdx)) {
        idx = RSZIdx;
    } else if (false && finished && !exists(parentof(this).tempN)) { // I dont know what to do with this anymore...
        for (idx=getRSZWaypointIndex(FTell(), lvl); idx<RSZFile[lvl].RSZHeader.instanceCount; idx++)
            if (startof(RSZFile[lvl].Data.RawData.RSZ[idx]) == startof(this) && exists(RSZFile[lvl].Data.RawData.RSZ[idx].var)) 
                 break;
    } else {
        idx = i; //in RawData (not on-demand?) Actually do this always
    }
    //if (!exists(RSZFile[lvl].InstanceInfos.instanceInfo[idx]))
   //     idx = 0;
    if (!IsInitialized() || (finished && idx && GetFieldCount(RSZFile[lvl].InstanceInfos.instanceInfo[idx].typeId.Hash) == 0xFFFFFFFF) ) { //|| GetFieldCount(RSZFile[lvl].InstanceInfos.instanceInfo[idx].typeId.Hash) == 0xFFFFFFFF
        if (!noRetry) {
            ParseJson(JsonPath);  Printf("\nParsing JSON %s\n", JsonPath);
            if (!IsInitialized() || (finished && idx && GetFieldCount(RSZFile[lvl].InstanceInfos.instanceInfo[idx].typeId.Hash) == 0xFFFFFFFF) )
                noRetry = TRUE;
        }
    }
    
    local string name <hidden=true> = RSZFile[lvl].InstanceInfos.instanceInfo[idx].typeId.HashName;
    local wstring title <hidden=true>; 
    local wstring secondTitle <hidden=true>;
    local uint hash <hidden=true, format=hex> = RSZFile[lvl].InstanceInfos.instanceInfo[idx].typeId.Hash;
    local ubyte isUserData <hidden=true>;

    if (exists(RSZFile[lvl].RSZUserDataInfos) && sizeof(RSZFile[lvl].RSZUserDataInfos) != 1)
        for (j=0; j<RSZFile[lvl].RSZHeader.userdataCount; j++)
            if (RSZFile[lvl].RSZUserDataInfos.userDataInfo[j].typeId.Hash == hash) 
                { isUserData = TRUE; break; }

    if (name == "Unknown Class!"){
        Printf("Hash %X not found in JSON!\n", hash);
        byte skip <hidden=true>;
    } else if (idx && GetFieldCount(hash) == 0xFFFFFFFF) { 
        Printf("Class %u %s not detected in JSON!\n", hash, name);
        byte skip <hidden=true>;
    } else if (isUserData) {
        byte skipFileData <hidden=true>;
        local short userDataIdx <hidden=true> = -1;
        for (j=0; j<RSZFile[lvl].RSZHeader.userdataCount; j++)
            if (RSZFile[lvl].RSZUserDataInfos.userDataInfo[j].instanceId == RSZ.idx) { 
                userDataIdx = j;
                if (RSZVersion != "RE2" && RSZVersion != "DMC5") {
                    local wstring userDataPath <hidden=true> = RSZFile[lvl].RSZUserDataInfos.userDataInfo[j].path.String; 
                    local wstring fullPath <hidden=true>;
                    ReadRSZPath(userDataPath);
                    if (title == "")
                        title = userDataPath;
                }
                break; 
            }
    } else if (idx && !FEof()) {
        local int z <hidden=true>, FieldType <hidden=true>, FieldSize <hidden=true>, IsList <hidden=true>;
        for (z = 0; z < GetFieldCount(hash); z++) {
            FieldType = (TypeIDs)GetFieldType(hash, z);
            FieldSize = GetFieldSize(hash, z);
            IsList = GetFieldArrayState(hash, z);
            if (IsList)
                FSeek(getAlignedOffset(FTell(), 4));
            else
                FSeek(getAlignedOffset(FTell(), GetFieldAlignment(hash, z)));   
            
            //Detect and set colors:
            if (FieldType == Color_tid) {
                temp = ((int)ReadUByte(FTell()+2)<<16 | (int)ReadUByte(FTell()+1)<<8 | (int)ReadUByte(FTell()));
                SetForeColor(temp); 
                SetBackColor(temp);
            } else if ((FieldSize == 16 && GetFieldAlignment(hash,z) == 16 && detectedColorVector(FTell())) && (findS(this.name, "olor") != -1 
            || findS(GetFieldName(hash,z), "olor") != -1 || (FieldType == Data_tid && findS(this.name, "render") != -1)) )  {
                temp = ( (int)readColorFloat(FTell()+8)<<16 | (int)readColorFloat(FTell()+4)<<8 | (int)readColorFloat(FTell()));
                SetForeColor(temp); 
                SetBackColor(temp);
            } else (!broken ) ? SetForeColor(cGreen) : SetForeColor(cYellow);
            
            if (FTell() + 4 <= FileSize() && ReadUInt(FTell()) != 0 && FieldType == Object_tid || FieldType == UserData_tid || FieldType == ukn_type 
            || (FieldType == Data_tid && FieldSize == 4 && FTell() + 4 + (IsList * 4) <= FileSize() && detectedObject(FTell() + (IsList * 4)))) {
                struct RSZVariable var(hash, z);
            } else {
                struct RSZVariable var(hash, z) <open=suppress>;
            }
            SetForeColor(cNone);
            SetBackColor(cNone);
        }
    } 
    if (!finished && FEof())
        i = RSZHeader.instanceCount; 
    
    if (title == "") {
        if (secondTitle != "") {
            title = secondTitle;
        } else if (exists(this.var[0])) {
            if (exists(this.var[0].RSZ)) {
                title = ReadRSZInstanceName(this.var[0].RSZ);
            } else {
                title = ReadRSZVariable(this.var[0]);
            }
        }
    }
    if (FTell() - startof(this)  == 0) { 
        if (!FEof())
            ubyte skipFileData <hidden=true>;
        else local ubyte skipFileData <hidden=true>;
    }
    if (FTell()==startof(this))
        Printf(name + "\n");
} RSZInstance <name=ReadRSZInstanceName, read=ReadRSZInstance, write=WriteRSZInstance>;

    wstring ReadRSZInstanceName(RSZInstance &r) { 
        local ushort lvl <hidden=true>;
        if (exists(parentof(r).lvl)) 
            lvl = parentof(r).lvl;
        else lvl = getLevel(startof(r));
        local string s;
        
        if (exists(r.idx)) {
            if (exists(r.skip) || exists(parentof(r).ObjectIndex) && exists(RSZFile[lvl].Data.RawData.RSZ[parentof(r).ObjectIndex].skip))
                s = "*";
            if (exists(RSZFile[lvl].InstanceInfos.instanceInfo[r.idx]))
                s += RSZFile[lvl].InstanceInfos.instanceInfo[r.idx].typeId.HashName;
            else if (exists(r.name))
                s += r.name;
            if (!exists(parentof(r).temp))
                SPrintf(s, "%s[%u]", s, r.idx);
        } else if (exists(RSZFile[lvl].RSZHeader)) {
            local uint idx;
            for (idx=getRSZWaypointIndex(startof(r), lvl);idx<RSZFile[lvl].RSZHeader.instanceCount;idx++) {
                if (exists(RSZFile[lvl].Data.RawData.RSZ[idx]) && !exists(RSZFile[lvl].Data.RawData.RSZ[idx].skipFileData) 
                && !exists(RSZFile[lvl].Data.RawData.RSZ[idx].skip) && startof(RSZFile[lvl].Data.RawData.RSZ[idx]) == startof(r)) { 
                    SPrintf(s, "%s[%u]", ReadRSZInstanceName(RSZFile[lvl].Data.RawData.RSZ[idx]), idx);
                    break;
                }
            }
        }
        return s;
    }

    int SizeRSZInstance(RSZInstance &r) { 
        local ushort idx;
        if (exists(parentof(r).lvl))
            local ushort lvl = parentof(r).lvl;
        else
            local ushort lvl = getLevel(startof(r));
        
        if ((exists(Alignment.varStart) && exists(RSZFile[lvl].Data.RawData.RSZ[ReadUInt(startof(Alignment.varStart))]))) //detectedObject(startof(Alignment.varStart))
            return sizeof(RSZFile[lvl].Data.RawData.RSZ[ReadUInt(startof(Alignment.varStart))]); 
        for (idx=getRSZWaypointIndex(startof(r), lvl);idx<RSZFile[lvl].RSZHeader.instanceCount;idx++) 
            if (startof(RSZFile[lvl].Data.RawData.RSZ[idx]) == startof(r) && !exists(RSZFile[lvl].Data.RawData.RSZ[idx].skipFileData))
                return sizeof(RSZFile[lvl].Data.RawData.RSZ[idx]);
        return 4;
    }

    int getRSZWaypointIndex(uint32 tell, ushort lvl) { 
        local short div = RSZFile[lvl].Data.RawData.divCounter-1;
        while (tell < RSZFile[lvl].Data.RawData.waypoints[div / 2])
            div = div / 2;
        for (div; div>0; div--)
            if (tell >= RSZFile[lvl].Data.RawData.waypoints[div])
                return (int)(div * 100);
        return 1;
    }

    wstring ReadRSZInstance(RSZInstance &r) {
        local ushort lvl;
        if (exists(parentof(r).lvl)) 
            lvl = parentof(r).lvl;
        else 
            lvl = getLevel(startof(r));
        if (exists(r.skip)) {
            return ReadHash(RSZFile[lvl].InstanceInfos.instanceInfo[r.idx].typeId.Hash);
        } else if (exists(r.skipFileData) && exists(RSZFile[lvl].RSZUserDataInfos)) {
            for (j=0; j<RSZFile[lvl].RSZHeader.userdataCount; j++)
                if (RSZFile[lvl].RSZUserDataInfos.userDataInfo[j].instanceId == r.idx)
                    return RSZFile[lvl].RSZUserDataInfos.userDataInfo[j].path.String;
        } else if (exists(r.title)) {
            return r.title;
        } else if (exists(parentof(r).ObjectIndex) && exists(RSZFile[lvl].Data.RawData.RSZ[parentof(r).ObjectIndex])) {
            return ReadRSZInstance(RSZFile[lvl].Data.RawData.RSZ[parentof(r).ObjectIndex]);
        } else {
            local ushort idx;
            for (idx=getRSZWaypointIndex(startof(r), lvl);idx<RSZFile[lvl].RSZHeader.instanceCount;idx++) 
                if (startof(RSZFile[lvl].Data.RawData.RSZ[idx]) == startof(r) && !exists(RSZFile[lvl].Data.RawData.RSZ[idx].skipFileData))
                    return RSZFile[lvl].Data.RawData.RSZ[idx].title;
        } return "";
    }

    void WriteRSZInstance(RSZInstance &r, wstring s) { 
        if (exists(r.fullPath) && s == " ")
            FileOpener(r.title);
        else {
            local int w;
            local string oldVar = ReadRSZInstance(r);
            while(exists(r.var[w])) {
                if (ReadRSZVariable(r.var[w]) == oldVar) {
                    WriteRSZVariable(r.var[w], s);
                    r.title = ReadRSZVariable(r.var[w]);
                    break;   
                }
                w++;
            }
        }
    }

//================= 
//Other typedefs:

typedef struct(int64 atAddress, int64 addOffset, byte isAbsolute) {
    if (isAbsolute < 1) {
        if (atAddress > -1)
            FSeek(atAddress);
        if (isAbsolute == 0) {
            uint64 strOffset;
            FSeek(strOffset + addOffset);
        } else { //for BHVTNodes
            uint strOffset;
            FSeek((strOffset * 2) + addOffset);
        }
    } else
        FSeek(atAddress + addOffset);
    wstring String <open=suppress>;
    
    if (find(String, "/") != -1 && FileNameGetExtension(String) != ".json") {
        local wstring _String <hidden=true> = String;
        local wstring fullPath <open=suppress, hidden=true>;
        ReadRSZPath(String);
    }
    if (exists(strOffset)) {
        if (atAddress == -1 || startof(this) == atAddress) {
            FSeek(startof(strOffset)+4+((isAbsolute != -1)*4));
        } else 
            FSeek(startof(this)+1);
    }
} StringRead <open=suppress, read=ReadStringRead, write=WriteStringRead>;

    wstring ReadStringRead(StringRead &st) { return st.String; }
    
    void WriteStringRead(StringRead &st, string s) { 
        if (s == " " && exists(st.fullPath) && st.fullPath != "")
            FileOpener(st.fullPath);
        else {
            char buffer[sizeof(st.String)];
            WriteBytes(buffer, startof(st.String), sizeof(st.String)); //write 0s
            st.String = s; 
        }
    }
    
    string PrefabName(StringRead &p) {
        if (exists(p.OpenFile))
            return "Prefab (Exists)";
        return "Prefab";
    }

typedef struct {
	uint32 Hash;
	local string HashName = ReadHashName(Hash);
} HASH <read=ReadHASH>;

    string ReadHASH (HASH &h) {
	    return ReadHash(h.Hash);
    }
    
    string ReadHash(uint32 &input) {
	    string s;
	    SPrintf(s, "%X", input);
	    return s;
    }
    
    string ReadHashName(uint32 &input) {
        if (!IsInitialized())
            ParseJson(JsonPath);
        return GetRSZClassName(input);
    }

    string ReadHASHWithName(HASH &h) {
        return ReadHash(h.Hash) + " -- " +  GetRSZClassName(h.Hash);
    }

typedef struct {
    wstring str;
} WSTRING <optimize=false, read=ReadWSTRING, write=WriteWSTRING>;
    wstring ReadWSTRING(WSTRING &input) { return input.str; }
    void WriteWSTRING(WSTRING &input, wstring s) {
        for (k = 0; k < sizeof(input.str)/2; k++)
            input.str[k] = 0;
        input.str = s;
    }

typedef struct {
    uint32 nameHash <format=hex>;
    uint32 type;
    //local wstring hashName <hidden=true>;
    switch (type) {
        case 6:
        case 7:  uint32 value; break;
        case 20: uint64 hashOffs; break;
        default:
            if (ReadUInt64(FTell()) > 0 && ReadUInt64(FTell()) <= FileSize()-16 && ReadUInt64(FTell()) > FTell()) {
                uint64 hashOffs; 
            } else if (detectedFloat(FTell())) {
                float value;
            } else {
                uint value;
            }
            break;
    }
    if (exists(value) && value > 0 && name == "CallbackNode")
        local wstring RSZClass <hidden=false> = GetRSZClassName(Value.value);
    
    if (exists(hashOffs)) {
        FSeek(start + hashOffs);
        rGUID value;
    }
    FSeek(startof(nameHash) + 16);
} UVAR_VALUE <read=ReadUVAR_VALUE, optimize=false>;

    string ReadUVAR_VALUE (UVAR_VALUE &input) {
        string s;
        if (exists(input.value))
            if (exists(input.RSZClass))
                return input.RSZClass;
            else if (sizeof(input.value)==16)
                return ReadrGUID(input.value);
            else if (detectedFloat(startof(input.value)))
                SPrintf(s, "%g", input.value);
            else 
                SPrintf(s, "%u", input.value);
        return s;
    }

typedef struct {
    ushort propCount, B, C;
    skipToNextLine();
    uint64 offs1, offs2;
    if (propCount > 0) {
        if (offs1 <= FileSize()) {
            FSeek(start + offs1);
            string name;
        }
        if (offs2 <= FileSize()) {
            FSeek(start + offs2);
            if (ReadUShort(FTell()+2) != 0)
                UVAR_VALUE Value;
        }
    }
    FSeek(startof(this)+32);
} SUBPROP2 <optimize=false>;

typedef struct {
    uint64 nameOffset;
    uint64 dataOffset;
    
    FSeek(start + nameOffset);
    string name <open=suppress>;
    
    FSeek(start + dataOffset);
    if (dataOffset > 0 && dataOffset + start <= FileSize())
        UVAR_VALUE Value;
    
    if (exists(Value.value)) {
        if (sizeof(Value.value)==16 && name == "VariableReferenceNode") {
            struct {
                local int tester <hidden=true> = ReadInt(startof(Value.value));
                local int tt <hidden=true>, rr <hidden=true>, vv <hidden=true>, doExit <hidden=true>;
                while (exists(RSZFile[tt])) {
                    rr=0;
                    while (exists(RSZFile[tt].Data.RawData.RSZ[rr])) {
                        vv=0;
                        while (exists(RSZFile[tt].Data.RawData.RSZ[rr].var[vv])) {
                            if (ReadInt(startof(RSZFile[tt].Data.RawData.RSZ[rr].var[vv])) == tester) {
                                FSeek(startof(RSZFile[tt].Data.RawData.RSZ[rr]));
                                struct RSZInstance RSZ; 
                                FSeek(startof(this)+4);  
                            }
                            vv++;
                        }
                        rr++;
                    }
                    tt++;
                }
            } VariableRef <size=4>;
            FSkip(-4);
        }
    }
    FSeek(startof(this)+32);
} UVAR_NODE <name=ReadUVAR_NODENAME, read=ReadUVAR_NODE, optimize=false>;

    string ReadUVAR_NODENAME (UVAR_NODE &input) { if (exists(input.name)) return input.name; return ""; }

    string ReadUVAR_NODE (UVAR_NODE &input) { if (exists(input.Value)) return ReadUVAR_VALUE(input.Value); return ""; }

typedef struct {
    ushort ukn, ukn, ukn, ukn, ukn, ukn, ukn, ukn;
} OFFSET2_DATA;

typedef struct {
    uint64 nodesOffset;
    uint64 offset2;
    ushort propCount, uknCount00, uknCount01; //skipToNextLine();
    if (propCount > 0) {
        if (nodesOffset > 0) {
            FSeek(start + nodesOffset);
            if (ReadUInt(FTell()) <= FileSize())
                struct UVAR_NODE Node[propCount];
            else 
                string name <open=suppress>;
        }
        if (offset2 > 0) {
            FSeek(start + offset2);
            struct OFFSET2_DATA Unknown;
            while ((ReadUInt64(FTell()) > FileSize() || ReadUInt64(FTell()+8) > FileSize()) && ReadByte(FTell()+2) == 0)
                struct OFFSET2_DATA Unknown;
        }
    }
    checkUseSpacers();
    if (FTell() < startof(this))
        FSeek(startof(this));
} UVAR_PROP <read=ReadUVAR_PROP, optimize=false>;  
    
    string ReadUVAR_PROP (UVAR_PROP &input) {
        if (exists(input.name))
            return input.name;
        if (exists(input.Node))
            return ReadUVAR_NODE(input.Node[0]);
        return "";
    }

typedef struct {
    rGUID Guid;
    uint64 nameOffset;
    FSeek(start + nameOffset);
    wstring name <open=suppress>;
    FSeek(startof(nameOffset) + 8);
    uint64 floatOffset, propOffset;
    uint type : 24;
    uint numBits : 8;
    uint nameHash;

    if (floatOffset > 0) { //!didSeek && 
        FSeek(start + floatOffset);
        
        if ((numBits / 32) <= 1) {
            float Value_As_Float;
            FSkip(-4);
            int Value_As_Int;
        } else {
            float Value_As_Float[(numBits / 32)];
            FSkip(-4);
            int Value_As_Int[(numBits / 32)];
        }
    }
    if (propOffset > 0) {
        FSeek(start + propOffset);
        struct UVAR_PROP VarData;           
    }
    FSeek(startof(nameHash) + 4);
} UVARIABLE <optimize=false, name=ReadUVariableName, read=ReadUVariable, write=WriteUVariable>;

    wstring ReadUVariableName(UVARIABLE &input) { if (exists(input.VarData)) return (input.name + "*"); return input.name; }

    void WriteUVariable(UVARIABLE &input, string s) { if (detectedFloat()) WriteFloat(startof(input.Value_As_Int), Atoi(s)); else WriteUInt(startof(input.Value_As_Int), Atoi(s)); }

    wstring ReadUVariable(UVARIABLE &input) {
        string s = "";
        if (exists(input.Value_As_Float)) {
            if (detectedFloat(startof(input.Value_As_Float)))
                SPrintf(s, "%g", input.Value_As_Float[0]);
            else
                SPrintf(s, "%u", input.Value_As_Int[0]); 
        }
        return (s);
    }

typedef struct {
    
    struct {
        uint version;
        uint magic;
        uint64 stringsOffset;
        uint64 dataOffset;
        uint64 embedsInfoOffset;
        uint64 hashInfoOffset;
        uint64 ukn;
        uint UVARhash;
        ushort variableCount;
        ushort embedCount;
        if (stringsOffset == 0 && variableCount == 0) {
            FSeek(hashInfoOffset+BHVTOffset);
            uint64 HashDataOffsets[4];
            FSeek(startof(HashDataOffsets)+32);
        }
    } Header;
    if (Header.magic == id_uvar) {
        if (Header.dataOffset + 64 < startof(this))
            local uint start = startof(this); 
        if (Header.variableCount && Header.dataOffset+start > startof(this)) { 
            FSeek(start + Header.dataOffset);
            struct {
                for (j=0;j<Header.variableCount;j++) {
                    struct UVARIABLE Var;
                }
            } Data;
        }
        if (Header.stringsOffset) { 
            FSeek(start + Header.stringsOffset);
            struct {
                if (Header.variableCount)
                    WSTRING str[Header.variableCount] <open=suppress>;
                else while (detectedString(FTell()))
                    WSTRING str <open=suppress>;
            } Strings;
        }
        
        if (Header.variableCount && Header.hashInfoOffset+start > startof(this)) {
            FSeek(start + Header.hashInfoOffset);
            struct {
                uint64 HashDataOffsets[4];
                FSeek(start + HashDataOffsets[0]);
                struct {
                    struct rGUID GUIDs[Header.variableCount] <optimize=false>;
                } GUIDs;
                FSeek(start + HashDataOffsets[1]);
                uint dataHashMap[Header.variableCount];
                FSeek(start + HashDataOffsets[2]);
                uint nameHashes[Header.variableCount];
                FSeek(start + HashDataOffsets[3]);
                uint nameHashMap[Header.variableCount];
            } HashData;
            if (FTell()+4 <= FileSize() && !exists(parentof(this).Uvar[1]) && ReadUInt()
            && ReadUInt64(FTell()+4)+start > FTell() && ReadUInt64(FTell()+4)+start < FileSize() )
                struct {
                    uint embedCount;
                    uint64 embedOffsets[embedCount];
                    for (i=0; i<embedCount; i++) {
                        FSeek(start + embedOffsets[i]);
                        struct UVAR UVAR_File;
                    }
                    //FSeek(startof(embedOffsets)+embedCount*8);
                } EmbeddedUVARs;
        }
    }
} UVAR <read=ReadUVAR>;

    wstring ReadUVAR (UVAR &input) {
        if (exists(input.Data.Var[0]))
            return input.Data.Var[0].name;
        return "";
    }

struct OBJECTID(int lv) {
    int id;
    local int level <hidden=true> = lv;
};

typedef OBJECTID ObjectId <read=ReadObjectIdTitle, write=WriteObjectId>;

    wstring ReadObjectIdName(ObjectId &o) {
        local string s;
        if (o.id > -1 && exists(RSZFile[o.level].ObjectTable[o.id]) && exists(RSZFile[o.level].InstanceInfos.instanceInfo[RSZFile[o.level].ObjectTable[o.id]])) {
            SPrintf(s, "%i -- %s", o.id, RSZFile[o.level].InstanceInfos.instanceInfo[RSZFile[o.level].ObjectTable[o.id]].typeId.HashName);
            if (s != "")
                SPrintf(s, "%s[%i]", s, RSZFile[o.level].ObjectTable[o.id]);
        }
        return s;
    }

    wstring ReadObjectId(ObjectId &o) {
        local string s;
        SPrintf(s, "%i", o.id);
        return s;
    }

    void WriteObjectId(ObjectId &o, string s) {
        o.id = Atoi(s);
    } 

    wstring ReadObjectIdTitle(ObjectId &o) {
        if (o.id > -1 && exists(RSZFile[o.level].ObjectTable[o.id]) 
        && exists(RSZFile[o.level].Data.RawData.RSZ[RSZFile[o.level].ObjectTable[o.id]])) {
            local string s = ReadObjectId(o) + " -- " + RSZFile[o.level].Data.RawData.RSZ[RSZFile[o.level].ObjectTable[o.id]].title;
            return s;
        }
        return "";
    }

    wstring ReadInstanceID(ObjectId &in) { 
        if (exists (RSZFile[in.level].InstanceInfos.instanceInfo[in.id].typeId.HashName)) {
            local string s; 
            SPrintf(s, "%i -- %s", in.id, RSZFile[in.level].InstanceInfos.instanceInfo[in.id].typeId.HashName);
            return s; 
        } 
        return ""; 
    }

void fakeGameObject() {
    FSeek(getAlignedOffset(FTell(), 4));
    local uint size0;
    if (size0 && FTell()+4+size0*2 <= FileSize())
        FSkip(4 + 2*size0);
    FSeek(getAlignedOffset(FTell(), 4));
    local uint size1;
    if (size1 && FTell()+4+size1*2 <= FileSize())
        FSkip(4 + 2*size1);
    FSeek(getAlignedOffset(FTell()+2, 4));
    uint timeScale;
}

/*struct fakeGameObject {
    
    uint size0;
    if (size0 && FTell()+size0*2 <= FileSize())
        wchar_t name[size0];
    FSeek(getAlignedOffset(FTell(), 4));
    uint size1;
    if (size1 && FTell()+size1*2 <= FileSize())
        wchar_t tag[size1];
    FSeek(getAlignedOffset(FTell()+2, 4));
    uint timeScale;
};*/

typedef struct(int structType, uint64 addOffset) {
    uint64 offset;
    FSeek(offset + addOffset);
    switch (structType) {
        case 0: struct RSZMagic RSZ <size=56>; break;
        case 1: struct RSZInstance RSZ <size=4>; break;
        default: break;
    }
    //checkUseSpacers();
    FSeek(startof(offset)+8);
} ReadStruct;// <read=ReadReadStruct, write=WriteReadStruct, size=8>;

    //string ReadReadStruct(ReadStruct &r) { local string s; SPrintf(s, "%i", r.offset); return s; }
    
    //void WriteReadStruct(ReadStruct &r, string s) { r.offset = Atoi(s); }
    
void fakeStateList() {
    local int count = ReadInt(); FSkip(4);
    if (count)
        FSkip(count * 4);
}

//Murmur3 hash generation by Darkness:
uint32 fmix32(uint32 h){
    h ^= h >> 16;
    h *= 0x85ebca6b;
    h ^= h >> 13;
    h *= 0xc2b2ae35;
    h ^= h >> 16;
    return h;
}

uint32 mmh3 (byte key[], uint32 length , uint32 seed){
    local uint64 block_start<hidden=true>;
    local const uint nBlocks = length / 4;
    local uint32 h1 = seed;
    
    local const uint32 c1 = 0xcc9e2d51;
    local const uint32 c2 = 0x1b873593;

    local uint32 k1;
    for(block_start = 0; block_start < nBlocks * 4; block_start+= 4){
        k1 = (uint32)key[block_start + 3] << 24 | \
             (uint32)key[block_start + 2] << 16 | \
             (uint32)key[block_start + 1] << 8 | \
             (uint32)key[block_start + 0];

        k1 = (c1 * k1) & 0xFFFFFFFF;
        k1 = (k1 << 15 | k1 >> 17) & 0xFFFFFFFF;
        k1 = (c2 * k1) & 0xFFFFFFFF;

        h1 ^= k1;
        h1 = (h1 << 13 | h1 >> 19) & 0xFFFFFFFF;
        h1 = (h1 * 5 + 0xe6546b64) & 0xFFFFFFFF;
    }

    local uint32 tail_index = nBlocks * 4;
    k1 = 0;
    local uint32 tail_size = length & 3;

    if(tail_size >= 3)
        k1 ^= (uint32)key[tail_index + 2] << 16;
    if(tail_size >= 2)
        k1 ^= (uint32)key[tail_index + 1] << 8;
    if(tail_size >= 1)
        k1 ^= (uint32)key[tail_index + 0];

    if(tail_size > 0){
        k1 = (k1 * c1) & 0xFFFFFFFF;
        k1 = (k1 << 15 | k1 >> 17) & 0xFFFFFFFF;
        k1 = (k1 * c2) & 0xFFFFFFFF;
        h1 ^= k1;
    }

    return fmix32(h1 ^ length);
}

uint32 hash_wide(string key){
    local uint64 it<hidden=true>;
    local const uint length = Strlen(key) * 2;
    if (length) {
        local byte key_array[length];
        for(it = 0; it < length; it += 2){
            key_array[it] = key[it / 2];
            key_array[it + 1] = 0;
        }
        return mmh3(key_array, length, 0xFFFFFFFF);
    } return 0;
}

typedef struct {
    ubyte dummy <hidden=true>;
    local string String_Form = "";
    local int Hash_Form;
} HashGenerator <read=ReadStringToHash, write=WriteStringToHash>;
    
    string ReadStringToHash(HashGenerator &h) { 
        if (h.Hash_Form )  {
            local string ss; SPrintf(ss, "%i = %s", h.Hash_Form, h.String_Form);
            return ss;
        } return "      [Input a String here to turn it into a Murmur3 Hash]"; 
    }
    
    void WriteStringToHash(HashGenerator &h, string s) {
        h.String_Form = s;
        h.Hash_Form = hash_wide(h.String_Form);
    }

typedef enum {
    id_SCN = 5129043,
    id_PFB = 4343376,
    id_USR = 5395285,
    id_RCOL = 1280262994,
    id_mfs2 = 846423661,
    id_BHVT = 1414940738,
    id_uvar = 1918989941
} MAGIC;


//Start of reading File =====================================================================================================================================
FSeek(0);
if (ReadUInt(0)==id_SCN || ReadUInt(0)==id_PFB || ReadUInt(0)==id_USR || ReadUInt(0)==id_RCOL || ReadUInt(4)==id_mfs2 || ReadUInt(0)==id_BHVT )
    struct {
        HashGenerator HashMaker <name="Hash Generator">;
        FSkip(-1);
        
        local MAGIC magic <hidden=true> = ReadUInt(FTell());
        if (ReadUShort(2) == 0)
            magic = ReadUInt(FTell()+4);
	    if (magic == id_BHVT)
            MAGIC magic;
        
        isAIFile = (findS(GetFileName(), "bhvt") != -1);
        
        if (magic == id_PFB) {
            MAGIC signature;
	        int infoCount;
            int resourceCount;
            
            if (RSZVersion != "DMC5" && RSZVersion != "RE2") {
                int uknPFBInfoCount;
                if (RSZVersion != "RE7") {
                    int userdataCount;
                    int reserved;
                }
                uint64 uknPFBInfoTbl;
	            uint64 resourceInfoTbl;
                if (RSZVersion != "RE7")
	                uint64 userdataInfoTbl;
            } else {
                int uknPFBInfoCount;
	            uint64 uknPFBInfoTbl;
	            uint64 resourceInfoTbl;
            }



	        uint64 dataOffset;
        }
    
        if (magic == id_USR) {
            MAGIC signature;
            int resourceCount;
            int userdataCount;
            int InfoCount;
	        uint64 resourceInfoTbl;
	        uint64 userdataInfoTbl;
	        uint64 dataOffset;
        }
        
        if (magic == id_RCOL) {
            MAGIC signature;
            int numGroups;
            int numShapes;
            int numUserData;
            int numRequestSets;
            uint maxRequestSetId;
            if (RSZVersion == "RE8" || RSZVersion == "MHRise") {
                int numIgnoreTags;
                int numAutoGenerateJoints;
            }
            uint userDataSize;
            uint status;
            if (RSZVersion == "RE3") {
                uint64 uknA; 
                uint64 uknB; 
            }
            uint64 groupsPtrTbl;
            uint64 dataOffset <name="userDataStreamPtr">;
            uint64 requestSetTbl; 
            if (RSZVersion == "RE8" || RSZVersion == "MHRise") {
                uint64 ignoreTagTbl;
                uint64 autoGenerateJointDescTbl;
            }
        }
        if (magic == id_SCN) {
            MAGIC signature;
            int infoCount;
            int resourceCount;
            int folderCount;
            if (RSZVersion == "DMC5" || RSZVersion == "RE2" || RSZVersion == "RE7") {
                int userdataCount;
                int prefabCount;
            } else {
                int prefabCount;
                int userdataCount;
            }
    
            uint64 folderInfoTbl;
            uint64 resourceInfoTbl;
            uint64 prefabInfoTbl;
            if (RSZVersion != "RE7")
                uint64 userdataInfoTbl;
            uint64 dataOffset;
        }
        
        if (ReadUInt(0) == id_BHVT || magic == id_mfs2) {
            if (magic == id_mfs2) {
                uint version;
                MAGIC signature;
                FSkip(8);
                uint64 treeData;
                uint64 transitionMapTbl;
                uint64 transitionDataTbl;
                uint64 treeInfoPtr;
                uint transitionMapCount;
                uint transitionDataCount;
                uint startTransitionDataIndex;
    
                FSeek(treeInfoPtr);
                uint treeDataSize;
    
                FSeek(transitionMapTbl);
                
                if (transitionMapCount) 
                    struct TRANSITIONMAP {
                        int transitionId;// <format=hex>;
                        int dataIndex;
                        
                        if ( exists(Header.TransitionData[dataIndex])) { //dataIndex > 0 &&
                            FSeek(startof(Header.TransitionData[dataIndex]));
                            struct TRANSITIONDATA TransitionData <open=true>;
                            checkUseSpacers();
                            FSeek(startof(dataIndex)+4);
                        }
                    } TransitionMap[transitionMapCount] <optimize=true>;
    
                FSeek(transitionDataTbl);
                if (transitionDataCount) 
                    struct TRANSITIONDATA {
                        int id <format=hex>;
                        enum {
                            EndType_None = 0x0,
                            EndType_EndOfMotion = 0x1,
                            EndType_ExitFrame = 0x2,
                            EndType_ExitFrameFromEnd = 0x3,
                            EndType_SyncPoint = 0x4,
                            EndType_SyncPointFromEnd = 0x5,
                        } endType : 4;
                        enum {
                            InterpolationMode_None = 0x0,
                            InterpolationMode_FrontFade = 0x1,
                            InterpolationMode_CrossFade = 0x2,
                            InterpolationMode_SyncCrossFade = 0x3,
                            InterpolationMode_SyncPointCrossFade = 0x4,
                            InterpolationMode_FrontOffsetFade = 0x5,
                            InterpolationMode_InertiaFade = 0x6,
                            InterpolationMode_FrontSpeedFade = 0x7,
                        } interpolationMode : 4;
                        enum {
                            InterpolationCurve_Linear = 0x0,
                            InterpolationCurve_Smooth = 0x1,
                            InterpolationCurve_EaseIn = 0x2,
                            InterpolationCurve_EaseOut = 0x3,
                        } interpolationCurve : 4;
                        uint32 prevMoveToEnd : 1;
                        enum {
                            StartType_None = 0x0,
                            StartType_Frame = 0x1,
                            StartType_NormalizedTime = 0x2,
                            StartType_SyncTime = 0x3,
                            StartType_AutoSyncTime = 0x4,
                            StartType_AutoSyncTimeSamePointCount = 0x5,
                        } startType : 4;
                        uint32 elapsedTimeZero : 1;
                        uint32 contOnLayer : 1;
                        uint32 contOnLayerInterpCurve : 4;
                        uint32 emptyBits : 9 <hidden=true>;
                        float exitFrame;
                        float startFrame;
                        float interpolationFrame;
                        if (RSZVersion != "RE2" && RSZVersion != "DMC5" ) {
                            float contOnLayerSpeed;
                            float contOnLayerTimeout;
                            uint16 contOnLayerNo;
                            uint16 contOnLayerJointMaskId;
                        }
                        FSkip(4);
                    } TransitionData[transitionDataCount] <optimize=true>;
                FSeek(startTransitionDataIndex+4);
            }
        }
        
        if (exists(treeData) || magic == id_BHVT) {
            if (exists(treeData))
                FSeek(treeData);
            else FSeek(startof(magic));
            struct {
                uint BHVT;
                FSkip(4);
                uint64 nodeOffset;
                uint64 actionOffset;
                uint64 selectorOffset;
                uint64 selectorCallerOffset;
                uint64 conditionsOffset;
                uint64 transitionEventOffset;
                uint64 expressionTreeConditionsOffset;
                uint64 staticActionOffset;
                uint64 staticSelectorCallerOffset;
                uint64 staticConditionsOffset;
                uint64 staticTransitionEventOffset;
                uint64 staticExpressionTreeConditionsOffset;
                uint64 stringOffset;
                uint64 resourcePathsOffset;
                uint64 userdataPathsOffset;
                uint64 variableOffset;
                uint64 baseVariableOffset;
                uint64 baseunknOffset; //it reads a empty 16 bytes, seperator?
                FSeek(startof(BHVT)+16);
                struct {
                    struct ReadStruct actionOffset(0, startof(BHVT));
                    struct ReadStruct selectorOffset(0, startof(BHVT));
                    struct ReadStruct selectorCallerOffset(0, startof(BHVT));
                    struct ReadStruct conditionsOffset(0, startof(BHVT));
                    struct ReadStruct transitionEventOffset(0, startof(BHVT));
                    struct ReadStruct expressionTreeConditionsOffset(0, startof(BHVT));
                    struct ReadStruct staticActionOffset(0, startof(BHVT));
                    struct ReadStruct staticSelectorCallerOffset(0, startof(BHVT));
                    struct ReadStruct staticConditionsOffset(0, startof(BHVT));
                    struct ReadStruct staticTransitionEventOffset(0, startof(BHVT));
                    struct ReadStruct staticExpressionTreeConditionsOffset(0, startof(BHVT));
                } RSZs;
                if (RSZVersion == "RE8" || RSZVersion == "MHRise")
                    uint64 referencePrefabGameObjectsOffset;
        
                FSeek(stringOffset+startof(this));
                struct BHVTStringPool{
                    if (exists(mPathNamePool) && !detectedString(FTell()+4))
                        uint numPaths;
                    uint poolSize;
                    while (FTell() < startof(this)+(poolSize*2)) {
                        if (exists(numPaths))
                            struct StringRead String(FTell(), 0, true) <read=ReadBHVTStringName2>;
                        else struct StringRead String(FTell(), 0, true) <read=ReadBHVTStringName>;
                        if (sizeof(String) == 0) 
                            break; 
                    }
                } mNamePool<bgcolor=0xAAAAAA>;
                FSeek(resourcePathsOffset+startof(this));
                struct BHVTStringPool mPathNamePool<bgcolor=0xAAAAAA>;
                if (exists(userdataPathsOffset) && ReadUInt(userdataPathsOffset+startof(this)) != 2) {
                    FSeek(userdataPathsOffset+startof(this));
                    struct BHVTStringPool mUserDataPathNamePool<bgcolor=0xAAAAAA>;
                }
                if (ReadBHVTHeader) {
                    FSeek(userdataPathsOffset+startof(this)-4); 
                    while (FTell()+8<FileSize() && ReadUInt(FTell()+4) != id_uvar) FSkip(1);
                    while(FTell() + 8 < FileSize()){
                        if (exists(Uvar[0]))
                            struct UVAR Uvar <hidden=false>;
                        else struct UVAR Uvar;
                        FSeek(startof(Uvar)+8);
                        while (FTell() + 8 < FileSize() && ReadUInt(FTell()+4) != id_uvar) 
                            FSkip(1);
                    }
                    FSeek(baseVariableOffset+startof(this));
                    
                    unsigned int mReferenceTreeCount;
                    if (FTell()+8 <= FileSize())
                        uint64 thisOffset;
                }
                FSeek(startof(baseVariableOffset) + 16);
            } BHVT<bgcolor=0xAAAAAA>;
        }
    } Header<bgcolor=0xAAAAAA>;
else {
    Printf("Header not detected\n");
    struct {
        local uint magic = ReadUInt();
        ubyte skip <hidden=true>;
    } Header;
    FSkip(-1);
}
    #include "TagsCollection.bt"

    typedef struct {
        struct BHVTCount mTagsCount(1); 
        if (!finished) {
            if (mTagsCount.Count > 1) 
                struct { 
                    for (i=0; i<mTagsCount.Count; i++) 
                        TagsCollection mTags <format=hex>; 
                } mTags; 
            else if (mTagsCount.Count == 1) TagsCollection mTags <format=hex>;
        } else {
            if (mTagsCount.Count && mTagsCount.Count < FileSize() && FTell() + mTagsCount.Count * 4 < RSZOffset)
                if (mTagsCount.Count > 1) { 
                    struct { 
                        struct BHVTHash mTags(id_Tags)[mTagsCount.Count]; 
                    } mTags <open=true>; 
                    checkUseSpacers();
                } else struct BHVTHash mTags(id_Tags) <open=true>;
        }
        ubyte mIsBranch <name="Bool IsBranch">;
        ubyte mIsEnd <name="Bool IsEnd">;
    } TAGS <name="Tags & Bools">; //read=ReadTAGs, write=WriteTAGs,
    
    typedef struct  {
        if (ReadInt(FTell() + (2 * (4 * childCount.Count))) == -1)
            struct BHVTHash ChildNode(id_All) <open=true>; 
        else 
            struct BHVTHash ChildNode(id_All); 
        FSkip(4 * childCount.Count - 4);
        struct BHVTHash ChildNodeEx(id_All); FSkip(4 * childCount.Count - 4);
        struct BHVTId Conditions(id_Conditions, 0);
        FSeek(startof(ChildNode)+4);
    } nChild <name=ReadnChildName, read=ReadnChild>;

    typedef struct {
        struct BHVTHash mActions(id_Actions) <open=true>;
        FSkip(4 * mActionsCount.Count - 4);
        struct BHVTHash mActionsEx(id_Actions);
        FSeek(startof(mActions)+4);
    } nAction <name="Action", read=ReadnAction>;

    typedef struct {
        FSkip((-4 * noStartState) * mTransitionCount.Count);
        struct BHVTHash mStartTransitionEvent(id_All);  FSkip(4 * mTransitionCount.Count - 4);
        if (detectedHash(FTell())) 
            struct BHVTHash mStartState(id_All);
        else
            struct BHVTId mStartState(id_All, 0);
        FSkip(4 * mTransitionCount.Count - 4);
        struct BHVTId mStartStateTransition(id_staticConditions, 0);
        if (RSZVersion != "RE2" && RSZVersion != "DMC5") {
            FSkip(4 * mTransitionCount.Count - 4);
            struct BHVTHash mStartStateEx(id_All);
        }
        FSeek(startof(this)+4);
    } nTransition <read=ReadnTransition, name=ReadnTransitionName>;
    
    typedef struct {
        FSeek(pos);
        struct BHVTId mStates(id_All, 1); 
        pos = FTell();
        for (j=mm+1; j<mStatesCount.Count; j++)
            fakeStateList();
        FSkip(mm * 4);
        struct BHVTHash mTransitions(id_All);  FSkip(4 * mStatesCount.Count - 4);
        struct BHVTId TransitionConditions(id_Conditions, 0); FSkip(4 * mStatesCount.Count - 4);
        struct BHVTHash TransitionMaps(id_TransitionId); FSkip(4 * mStatesCount.Count - 4);
        struct BHVTHash mTransitionAttributes(id_All);  FSkip(4 * mStatesCount.Count - 4);
        struct BHVTHash mStatesEx(id_All); 
        FSeek(startof(mTransitions)+sizeof(mTransitions));
    } nState <read=ReadnState, name=ReadnStateName>;

    typedef struct {
        struct BHVTHash mAllState(id_All); FSkip(4 * mAllStateCount.Count - 4);
        struct BHVTId mAllTransition(id_TransitionId, 0); FSkip(4 * mAllStateCount.Count - 4);
        struct BHVTHash mAllTransitionID(id_TransitionId); FSkip(4 * mAllStateCount.Count - 4);
        struct BHVTHash mAllStateEx(id_All); FSkip(4 * mAllStateCount.Count - 4);
        struct BHVTHash mAllTransitionAttributes(id_All);
        FSeek(startof(mAllState)+4);
    } nAllState <read=ReadnAllState, name=ReadnAllStateName>;

    if (exists(Header.BHVT) && ReadBHVTHeader) {
        
        //if (isAIFile) local uint mPriorityMax, unknownAImax, unknownAI2max;
        
        FSeek(Header.BHVT.nodeOffset+startof(Header.BHVT));
        struct  {
            uint32 mNodeCount;
            local uint32 mNodeCounter <hidden=true>;
            struct RAWNODES { 
                typedef struct {
                    local uint32 index <hidden=true>;
                    local uint mm <hidden=true>;
                    
                    if (exists(mNodeCounter)) {
                        index = mNodeCounter;
                    } else { 
                        for (index=getBHVTWaypointIndex(FTell()); index<BehaviorTree.mNodeCount; index++)
                            if (startof(this) == startof(BehaviorTree.RawNodes.Node[index]))
                                break;
                    }
                    
                    local ubyte isEnd <hidden=true>, isBranch <hidden=true>;
                    struct BHVTHash ID(id_Actions); 
                    struct BHVTHash exID(id_Actions);
                    StringRead mNameOffset(-1, 4+startof(Header.BHVT)+Header.BHVT.stringOffset, -1);
                    if (!exists(ID) || ID.hash != ReadInt())
                        struct BHVTHash mParent(id_All);
                    else 
                        int mParent;
                    struct BHVTHash mParentEx(id_All);
                    
                    if (ReadInt() > 0) {
                        struct nChildContainer {
                            struct BHVTCount childCount(3);
                            if (childCount.Count && childCount.Count < FileSize() && FTell() + childCount.Count * 4 < RSZOffset) {
                                for (mm=0; mm<childCount.Count; mm++) {
                                    if (childCount.Count == 1) {
                                        struct nChild Child <open=true>;
                                        checkUseSpacers();
                                    } else 
                                        struct nChild Child;
                                }
                                FSeek(startof(Child.Conditions)+4);
                            }
                        } ChildNodes <name="Child Nodes", read=ReadnChildContainer>;
                    } else 
                        struct BHVTCount childCount(3); 
                    
                    struct BHVTId SelectorID(id_Selectors, 0);
                    
                    if (ReadInt() > 0) {
                        struct {
                            struct BHVTCount selectorCallersCount(1); 
                            if (selectorCallersCount.Count && selectorCallersCount.Count < FileSize() && FTell() + selectorCallersCount.Count * 4 < RSZOffset) {
                                if (selectorCallersCount.Count > 1) struct { struct BHVTId selectorCallers(id_SelectorCallers, 0)[selectorCallersCount.Count]; } selectorCallers; else struct BHVTId selectorCallers(id_SelectorCallers, 0);
                            }
                        } SelectorCallers;
                    } else 
                        struct BHVTCount selectorCallersCount(1);
                    
                    struct BHVTId mSelectorCallConditionID(id_Selectors, 0);
                    
                    if (ReadInt() > 0) {
                        typedef struct  {
                            struct BHVTCount mActionsCount(2);  
                            if (mActionsCount.Count && mActionsCount.Count < FileSize() && FTell() + mActionsCount.Count * 4 < RSZOffset) {
                                for (mm=0; mm<mActionsCount.Count; mm++) {
                                    if (mActionsCount.Count == 1) {
                                        struct nAction Action <open=true>;
                                        checkUseSpacers();
                                    } else 
                                        struct nAction Action;
                                    if (mm < mActionsCount.Count-1) 
                                        FSeek(startof(Action.mActions)+sizeof(Action.mActions));
                                }
                                FSeek(startof(Action.mActionsEx)+4);
                            }
                        } nActionsContainer <name="Actions", read=ReadnActionsContainer>;
                        if (ReadInt() == 1)
                            struct nActionsContainer Actions;
                        else 
                            struct nActionsContainer Actions <open=true>;
                    } else 
                        struct BHVTCount mActionsCount(2);
                    
                    int mPriority;   //if (mPriority > mPriorityMax) mPriorityMax = mPriority;
                    
                    if (!isAIFile) {
                        struct {
                            if (ReadInt() & 0x20) {
                                local uint mNodeAttribute <hidden=true> = ReadUInt(FTell());
                                enum <uint16> {
                                    NodeAttribute_IsEnabled = 0x1,
                                    NodeAttribute_IsRestartable = 0x2,
                                    NodeAttribute_HasReferenceTree = 0x4,
                                    NodeAttribute_BubblesChildEnd = 0x8,
                                    NodeAttribute_SelectOnce = 0x10,
                                    NodeAttribute_IsFSMNode = 0x20,
                                    NodeAttribute_TraverseToLeaf = 0x40,
                                } NodeAttribute;
                                enum <uint16> {
                                    WorkFlags_IsNotifiedEnd = 0x1,
                                    WorkFlags_HasEvaluated = 0x2,
                                    WorkFlags_HasSelected = 0x4,
                                    WorkFlags_IsCalledActionPrestart = 0x8,
                                    WorkFlags_IsCalledActionStart = 0x10,
                                    WorkFlags_IsNotifiedUnderLayerEnd = 0x20,
                                    WorkFlags_IsBranchState = 0x40,
                                    WorkFlags_IsEndState = 0x80,
                                    WorkFlags_IsStartedSelector = 0x100,
                                    WorkFlags_OverridedSelector = 0x200,
                                    WorkFlags_DuplicatedAction = 0x400,
                                    WorkFlags_IsAsRestartable = 0x800,
                                } WorkFlags;

                                int mNameHash <format=hex>;
                                int mFullnameHash <format=hex>;
                            } else int mNodeAttribute;
                        } Node_Attributes;
                        
                        if (Node_Attributes.mNodeAttribute & 0x20) {
                            isBranch = ReadByte(FTell()+(4+(ReadInt(FTell())*4)));
                            isEnd = ReadByte(FTell()+(5+(ReadInt(FTell())*4)));
                            //local uint branchLoc =  ((4+(ReadInt(FTell())*4)));
                            if (finished)
                                struct TAGS Tags <size=GetTagsSize>;
                            else 
                                struct TAGS Tags;
                        }
                    }

                    if (!isAIFile) {
                        if (ReadInt() > 0) {
                            struct nStatesContainer {
                                struct BHVTCount mStatesCount(6);
                                local uint pos <hidden=true>;
                                if (mStatesCount.Count && mStatesCount.Count < FileSize() && FTell() + mStatesCount.Count * 4 < RSZOffset) {
                                    for (mm=0; mm<mStatesCount.Count; mm++) {
                                        pos = FTell();
                                        for (j=mm; j<mStatesCount.Count; j++) //complicated...
                                            fakeStateList();
                                        FSkip(mm * 4);
                                        if (mStatesCount.Count == 1) {
                                            struct nState State <open=true>;
                                            checkUseSpacers();
                                        } else 
                                            struct nState State;
                                        FSeek(startof(State.mStates)+sizeof(State.mStates));
                                    }
                                    FSeek(startof(State.mStatesEx)+4);
                                }
                            } States <name="States", read=ReadnStatesContainer>;
                        } else 
                            struct BHVTCount mStatesCount(6);
                        
                        if (ReadInt() > 0) {
                            struct nTransitionsContainer {
                                local ubyte noStartState <hidden=true>;
                                if (RSZVersion != "RE2" && RSZVersion != "DMC5") 
                                    struct BHVTCount mTransitionCount(4);
                                else 
                                    struct BHVTCount mTransitionCount(3);
                                if (mTransitionCount.Count && mTransitionCount.Count < FileSize() && FTell() + mTransitionCount.Count * 4 < RSZOffset) {
                                    for (mm=0; mm<mTransitionCount.Count; mm++) {
                                        noStartState = FALSE;
                                        if (!detectedHash(FTell())) {
                                            noStartState = TRUE;
                                            FSkip(4 * mTransitionCount.Count);
                                        }
                                        if (mTransitionCount.Count == 1) {
                                            struct nTransition Transition <open=true>;
                                            checkUseSpacers();
                                        } else 
                                            struct nTransition Transition;
                                        if (mm < mTransitionCount.Count-1) 
                                            FSeek(startof(Transition.mStartTransitionEvent) + 4);
                                    }
                                    if (RSZVersion != "RE2" && RSZVersion != "DMC5") 
                                        FSeek(startof(Transition.mStartStateEx)+4);
                                    else 
                                        FSeek(startof(Transition.mStartStateTransition)+4);
                                }
                            } Transitions <name="Transitions", read=ReadnTransitionsContainer>;
                            
                        } else if (RSZVersion != "RE2" && RSZVersion != "DMC5") 
                            struct BHVTCount mTransitionCount(4);
                        else 
                            struct BHVTCount mTransitionCount(3);
                        
                        
                        
                        if (exists(Node_Attributes) && (Node_Attributes.mNodeAttribute & 4) == 0) {
                            if (ReadInt() > 0) {
                                struct nAllStatesContainer {
                                    struct BHVTCount mAllStateCount(5);
                                    if (mAllStateCount.Count && mAllStateCount.Count < FileSize() && FTell() + mAllStateCount.Count * 4 < RSZOffset) {
                                        for (mm=0; mm<mAllStateCount.Count; mm++) {
                                            if (mAllStateCount.Count == 1) {
                                                struct nAllState AllState <open=true>;
                                                checkUseSpacers();
                                            } else 
                                                struct nAllState AllState;
                                            if (mm < mAllStateCount.Count-1) 
                                                FSeek(startof(AllState.mAllState)+sizeof(AllState.mAllState));
                                        }
                                        FSeek(startof(AllState.mAllTransitionAttributes)+4);
                                    }
                                } AllStates <name="AllStates", read=ReadnAllStatesContainer>;
                            } else 
                                struct BHVTCount mAllStateCount(5); 
                        }
                        
                        int mReferenceTreeIndex;
                        
                    } else {
                        uint unknownAI;  //if (unknownAI > unknownAImax) unknownAImax = unknownAI;
                        uint unknownAI2; //if (unknownAI2 > unknownAI2max) unknownAI2max = unknownAI2;
                    }
                    
                    if (RedetectBHVT && !finished ) { //automatic correction, seeks to next node
                        if (ReadInt()==0 || !detectedHash(FTell()) ) { //!detectedNode(FTell())
                            if (mNodeCounter < mNodeCount-2) {
                                ubyte blank <hidden=true>;
                                FSeek(startof(mPriority)+4);
                                while (!detectedNode(FTell())) {
                                    if (FTell()>=startof(blank))
                                        ushort skip <hidden=true, bgcolor=cRed>;
                                    else FSkip(2);
                                }
                                Printf("Redetected BHVT Node from %u to %u\n",  startof(blank), FTell()); 
                            }
                        }
                        mNodeCounter++;
                    }
                } BHVTNode <name=ReadBHVTNodeName, read=ReadBHVTNode, optimize=false, open=suppress, bgcolor=0xAAAAAA>;
                
                local uint maxDivs <hidden=true> = mNodeCount / 100 + 1;
                local uint waypoints[maxDivs] <hidden=true>; 
                local uint divCounter <hidden=true>;
                
                for (n=0; n<mNodeCount; n++) { //divides list up into 100 node intervals
                    if (n == (100 * divCounter)) {
                        waypoints[divCounter] = FTell();
                        divCounter++;
                    }
                    struct BHVTNode Node;
                    if (FTell()>RSZOffset)
                        break;
                }
            };
            
            if (HideRawNodes) 
                struct RAWNODES RawNodes <hidden=true, open=suppress>;
            else struct RAWNODES RawNodes <open=suppress>;
            
            struct {
                uint32 actionSize;
                if (actionSize && actionSize * 4 + FTell() < FileSize())
                    struct { uint actionZeros[actionSize]; } actionZeroes;
                uint32 staticActionSize;
                if (staticActionSize && staticActionSize * 4 + FTell() < FileSize()) 
                    struct { uint staticActionZeroes[staticActionSize]; } staticActionZeroes;
            } zeroes;
            
        } BehaviorTree<bgcolor=0xAAAAAA>;
    }

        wstring ReadBHVTNodeName(BHVTNode &b) { 
            if (exists(b.isBranch)) {
                return FormBHVTNodeReaderString(b, "Node");
            } else {
                local ushort z;
                for (z=getBHVTWaypointIndex(startof(b)); z<BehaviorTree.mNodeCount; z++)
                    if (startof(b) == startof(BehaviorTree.RawNodes.Node[z])) {
                        return FormBHVTNodeReaderString(BehaviorTree.RawNodes.Node[z], "Node");
                    }
            }
            return "Node";
        }
        
        //This fn allows the nodes list to be scanned much more quickly by the reader function, dividing it up into 10ths:
        int getBHVTWaypointIndex(uint32 tell) { 
            local ushort div;
            for (div=BehaviorTree.RawNodes.divCounter-1; div>=0; div--)
                if (tell >= BehaviorTree.RawNodes.waypoints[div])
                    return div * 100; //(int)(BehaviorTree.mNodeCount * (div * 0.1));
            return 0;
        }
        
        string FormBHVTNodeReaderString(BHVTNode &b, string s) {
            local string ss = "(";
            if (exists(b.ChildNodes))                     ss += "C,";
            if (exists(b.Actions))                        ss += "A,";
            if (exists(b.Tags) && sizeof(b.Tags) > 6)     ss += "G,";
            if (exists(b.States))                         ss += "S,";
            if (exists(b.Transitions))                    ss += "T,";
            if (exists(b.AllStates))                      ss += "L,";
            if (b.isBranch) s += "*";
            if (b.isEnd)    s += "^";
            ss == "(" ? ss = "" : ss = StrDel(ss, sizeof(ss)-2, 1) + ") ";
            return s + " " + ss;
        }
        
        wstring ReadBHVTNode(BHVTNode &b) { 
            local string s;
            if (exists(b.mNameOffset.String)) {
                SPrintf(s, " [%i]", b.index);  
                return b.mNameOffset.String + s;
            } else {
                local ushort z;
                for (z=getBHVTWaypointIndex(startof(b)); z<BehaviorTree.mNodeCount; z++)
                    if (startof(b) == startof(BehaviorTree.RawNodes.Node[z])) {
                        SPrintf(s, " [%i]", z);
                        return BehaviorTree.RawNodes.Node[z].mNameOffset.String + s;
                    }
            }
            return s;
        }

        string ReadBHVTNodeNameWithVarName(BHVTNode &b, string varName) { 
            if (exists(b.isBranch)) {
                return FormBHVTNodeReaderString(b, varName);
            } else {
                local ushort z;
                for (z=getBHVTWaypointIndex(startof(b)); z<BehaviorTree.mNodeCount; z++) {
                    if (startof(b) == startof(BehaviorTree.RawNodes.Node[z])) {
                        return FormBHVTNodeReaderString(BehaviorTree.RawNodes.Node[z], varName);
                    }
                }
            }
            return varName;
        }

        int SizeBHVTNode(BHVTNode &b) {
            local ushort z;
            for (z=getBHVTWaypointIndex(startof(b)); z<BehaviorTree.mNodeCount; z++) {
                if (startof(b) == startof(BehaviorTree.RawNodes.Node[z]))
                    return sizeof(BehaviorTree.RawNodes.Node[z]);
            }
            return 4;
        }
        
        wstring ReadBHVTStringName(StringRead &str) { 
            SPrintf(s, "%i -- ", ((startof(str) - startof(parentof(str))) - 4) / 2); 
            return s + ReadStringRead(str); 
        } 
    
        wstring ReadBHVTStringName2(StringRead &str) { 
            SPrintf(s, "%i -- ", ((startof(str) - startof(parentof(str))) - 8) / 2); 
            return s + ReadStringRead(str); 
        } 
    
        int ReadBHVTStringID(StringRead &str) { 
            return (startof(str) - startof(parentof(str)) - 4) / 2; 
        } 
        
        int GetTagsSize (TAGS &t) { return (6 + ReadUInt(startof(t)) * 4); }

        wstring ReadnChild (nChild &c) { return ReadBHVTHash(c.ChildNode); } 

        wstring ReadnChildName(nChild &n) { if (exists(n.ChildNode.Node)) return ReadBHVTNodeNameWithVarName(n.ChildNode.Node, "Child"); return ""; }

        wstring ReadnAction (nAction &a) { return ReadBHVTHash(a.mActions); }

        wstring ReadnState (nState &s) { return ReadBHVTHash(s.mTransitions); }

        wstring ReadnStateName(nState &s) { if (exists(s.mTransitions.Node)) return ReadBHVTNodeNameWithVarName(s.mTransitions.Node, "State"); return ""; }

        wstring ReadnTransition (nTransition &t) { 
            if (ReadInt(startof(t.mStartTransitionEvent))) 
                return ReadBHVTHash(t.mStartTransitionEvent); 
            if (exists(t.mStartState.hash))
                return ReadBHVTHash(t.mStartState); 
            return ReadBHVTId(t.mStartState); 
        }

        wstring ReadnTransitionName(nTransition &t) { 
            if (exists(t.mStartState.Node)) 
                return ReadBHVTNodeNameWithVarName(t.mStartState.Node, "Transition");
            else if (exists(t.mStartTransitionEvent.Node))
                return ReadBHVTNodeNameWithVarName(t.mStartTransitionEvent.Node, "Transition"); 
            else return "Transition";
        }

        wstring ReadnAllState (nAllState &a) { return ReadBHVTHash(a.mAllState); }

        wstring ReadnAllStateName(nAllState &a) { if (exists(a.mAllState.Node)) return ReadBHVTNodeNameWithVarName(a.mAllState.Node, "AllState"); return ""; }

        wstring ReadNodeTagsName(BHVTNode &n) { return ReadBHVTNodeNameWithVarName(n, "Node w/ same tag"); }

        wstring ReadnStatesContainer(nStatesContainer &c) {
            if (c.mStatesCount.Count && exists(c.State[c.mStatesCount.Count-1]) && c.mStatesCount.Count > 1) return ReadnState(c.State[0])+" ~ "+ReadnState(c.State[c.mStatesCount.Count-1]);
            return ReadnState(c.State[0]);
        }
        wstring ReadnActionsContainer(nActionsContainer &c) {
            if (exists(c.Action[c.mActionsCount.Count-1]) && c.mActionsCount.Count > 1) return ReadnAction(c.Action[0])+" ~ "+ReadnAction(c.Action[c.mActionsCount.Count-1]);
            return ReadnAction(c.Action[0]);
        }
        wstring ReadnChildContainer(nChildContainer &c) {
            if (exists(c.Child[c.childCount.Count-1]) && c.childCount.Count > 1) return ReadnChild(c.Child[0])+" ~ "+ReadnChild(c.Child[c.childCount.Count-1]);
            return ReadnChild(c.Child[0]);
        }
        wstring ReadnAllStatesContainer(nAllStatesContainer &c) {
            if (exists(c.AllState[c.mAllStateCount.Count-1]) && c.mAllStateCount.Count > 1) return ReadnAllState(c.AllState[0])+" ~ "+ReadnAllState(c.AllState[c.mAllStateCount.Count-1]);
            return ReadnAllState(c.AllState[0]);
        }
        
        wstring ReadnTransitionsContainer(nTransitionsContainer &c) {
            if (exists(c.Transition[c.mTransitionCount.Count-1]) && c.mTransitionCount.Count > 1) return ReadnTransition(c.Transition[0])+" ~ "+ReadnTransition(c.Transition[c.mTransitionCount.Count-1]);
            return ReadnTransition(c.Transition[0]);
        }
        
    typedef struct {
        HASH hash <read=ReadHASHWithName>;
        uint32 CRC;
        StringRead pathOffset(-1, 0, 0);
    } UserDataInfo <name=ReadUserDataInfoName, read=ReadUserDataInfo>;
    
        string ReadUserDataInfo (UserDataInfo &u) { return u.pathOffset.String; }
        
        string ReadUserDataInfoName(UserDataInfo &u) { return u.hash.HashName; }
    
    typedef struct {
        if (ReadInt(FTell()+4) != 0)
            StringRead pathStr(FTell(), 0, 1); 
        else
            StringRead pathStr(-1, 0, 0);
    } Resource_Info <name=ReadResourceInfoName, read=ReadResourceInfo, write=WriteResourceInfo>;
    
        string ReadResourceInfo(Resource_Info &r) { return r.pathStr.String; }
    
        string ReadResourceInfoName(Resource_Info &r) { if (!exists(r.pathStr.OpenFile) && !exists(r.OpenFile)) return "*ResourceInfo"; return "ResourceInfo"; }
    
        void WriteResourceInfo(Resource_Info &r, string s) { WriteStringRead(r.pathStr, s);  }

        string ReadGameObjectString(ubyte &dd) {
            local ushort ii = RSZFile[0].ObjectTable[parentof(dd).id.id];
            local ushort compCtr;
            local string str;
            while(exists(RSZFile[0].InstanceInfos.instanceInfo[ii]) && compCtr < parentof(dd).componentCount + 1) {
                if (RSZFile[0].InstanceInfos.instanceInfo[ii].isObject) {
                    SPrintf(str, "%s *%i_%i", str, RSZFile[0].InstanceInfos.instanceInfo[ii].typeId.Hash, RSZFile[0].InstanceInfos.instanceInfo[ii].CRC);
                    compCtr++;
                } else
                    SPrintf(str, "%s %i_%i", str, RSZFile[0].InstanceInfos.instanceInfo[ii].typeId.Hash, RSZFile[0].InstanceInfos.instanceInfo[ii].CRC);
                ii++;
            }
            return str;
        }

        void CheckRSZVariable(RSZVariable &v, int greaterThan, int addAmt) {
            local int fx;
            while(exists(v.var[fx])) {
                CheckRSZVariable(v.var[fx], greaterThan, addAmt);
                fx++;
            }
            if (exists(v.ObjectIndex) && v.ObjectIndex > greaterThan)
                v.ObjectIndex += addAmt;
            if (exists(v.RSZIdx) && v.RSZIdx > greaterThan)
                v.RSZIdx += addAmt;
        }
        
        void CheckInstance(RSZInstance &r, int greaterThan, int addAmt) {
            local int fx;
            while(exists(r.var[fx])) {
                if (exists(r.var[fx].ObjectIndex) || exists(r.var[fx].var))
                    CheckRSZVariable(r.var[fx], greaterThan, addAmt);
                fx++;
            }
        }
        
        void FixObjects(int lvl, int greaterThan, int addAmt) {
            local int ix;
            while(exists(RSZFile[lvl].Data.RawData.RSZ[ix])) {
                CheckInstance(RSZFile[lvl].Data.RawData.RSZ[ix], greaterThan, addAmt);
                ix++;
            }
        }

        local int64 stringPadOffset <hidden=true> = -1;
        int SimulatePaddingSize(uint classHash, uint tell, ubyte padStringPadding) {
            local uint newTell = tell;
            if (!IsInitialized())
                ParseJson(JsonPath);
            for (j=0; j<GetFieldCount(classHash); j++) {
                if (padStringPadding && !GetFieldArrayState(classHash, j) && stringPadOffset == -1 && GetFieldType(classHash, j) == String_tid) {
                    stringPadOffset = getAlignedOffset(newTell, 4);
                    newTell = stringPadOffset + GetFieldSize(classHash, j) + padStringPadding;
                } else 
                    newTell = getAlignedOffset(newTell, GetFieldAlignment(classHash, j)) + GetFieldSize(classHash, j);
            }
            return newTell - tell;
        }
        
        void addInsertBookmark() {
            for (i=0; i<GetNumBookmarks(); i++) 
                if (GetBookmarkName(i) == "RSZ_Data_InsertPt") 
                    RemoveBookmark(i);
            AddBookmark(GetCursorPos()-1, "RSZ_Data_InsertPt", "ubyte", -1, cNone, cPurple, 0);
        }
        
        void InstanceWriterMethod(string s, ushort lvl, short insertIndex, ubyte structType) {
            local short i, j, ctr, padBytes, newId;
            local string tmp = s;
            local short Arr[(sizeof(s)/8) + 2];
            local short gObjectSz;
            if (structType == 2) //FolderInfo
                gObjectSz = 8;
            if (structType == 1) //GameObject
                Header.magic == id_PFB ? gObjectSz = 12 : gObjectSz = 32;
            local ubyte instanceSize = 8 + (RSZVersion=="RE7") * 8;
            local short sizeToAdd = gObjectSz;
            local short objectCtr;
            newId = RSZFile[lvl].RSZHeader.objectCount;
            if (exists(GameObjectInfos))
                local uint GameObjectsEnd = startof(GameObjectInfos) + sizeof(GameObjectInfos) - (Header.infoCount == 0);
            if (exists(FolderInfos))
                local uint FolderInfosEnd = startof(FolderInfos) + sizeof(FolderInfos) - (Header.folderCount == 0);
            

            //calculate ObjectTable added size:
            local short index = findS(s, " ");
            while(index > -1) {
                Arr[ctr] = index + 1 + ctr;
                if (s[Arr[ctr]] == 0x2A) {
                    sizeToAdd+=instanceSize+4;
                    objectCtr++;
                } else 
                    sizeToAdd+=instanceSize;
                tmp = StrDel(tmp, index, 1);
                index = findS(tmp, " ");
                ctr++;
            }
        
            //calculate padding
            local uint padPt = (startof(RSZFile[lvl].InstanceInfos) + sizeof(RSZFile[lvl].InstanceInfos));
            local uint existingPadding;
            while(ReadByte(padPt + existingPadding) == 0) 
                existingPadding++;
            while((padPt + sizeToAdd + padBytes ) % 16 != (padPt) % 16)
                padBytes++;
            if (existingPadding + padBytes > 16)
                padBytes -= 16;
            sizeToAdd += padBytes;

            //calculate new Data Size (as all 00's)
            local uint newDataSize;
            if (insertIndex < RSZFile[lvl].RSZHeader.instanceCount-1) {
                local uint tempSz, newDataPadSz;
                local uint newDataInsertPt = startof(RSZFile[lvl].Data.RawData.RSZ[insertIndex])+sizeof(RSZFile[lvl].Data.RawData.RSZ[insertIndex])+sizeToAdd
                    - exists(RSZFile[lvl].Data.RawData.RSZ[insertIndex].skipFileData);
                local uint newDataRollingInsertPt = newDataInsertPt;
                for (i=0; i<ctr; i++) {
                    tmp = SubStr(s, Arr[i], Arr[i+1] - Arr[i]);
                    if (tmp[0] == 0x2A)
                        tmp = StrDel(tmp, 0, 1);
                    tempSz = SimulatePaddingSize(Atoi(tmp), newDataRollingInsertPt, 0);
                    newDataRollingInsertPt += tempSz;
                    newDataSize += tempSz;
                }

                //pad it out with a string if possible:
                while((newDataRollingInsertPt + newDataPadSz) % 16 != newDataInsertPt % 16) //all that just to find where it ends..
                    newDataPadSz++;
                newDataSize = 0;
                newDataRollingInsertPt = newDataInsertPt;
                for (i=0; i<ctr; i++) {
                    tmp = SubStr(s, Arr[i], Arr[i+1] - Arr[i]);
                    if (tmp[0] == 0x2A)
                        tmp = StrDel(tmp, 0, 1);
                    if (find(GetRSZClassName(Atoi(tmp)), "UserData") == -1) {
                        tempSz = SimulatePaddingSize(Atoi(tmp), newDataRollingInsertPt, newDataPadSz);
                        newDataRollingInsertPt += tempSz;
                        newDataSize += tempSz;
                    }
                }
                sizeToAdd += newDataSize;
                FixObjects(lvl, insertIndex, ctr);
            }
            
            //Printf("%s %i %i %i %i %i %i %i %i\n", s, structType, lvl, gObjectSz, padBytes, existingPadding, sizeToAdd, FolderInfosEnd, padPt);
            
            //fix offsets
            if (structType == 1) {
                FixOffsets(0, RSZOffset, GameObjectsEnd+1, gObjectSz, 0);
                if (sizeof(GameObjectInfos) == 1)
                    FixOffsets(startof(Header.folderInfoTbl), startof(Header.folderInfoTbl)+40, GameObjectsEnd - startof(Header.resourceInfoTbl), gObjectSz, 0);
            } else if (structType == 2) {
                FixOffsets(0, RSZOffset, FolderInfosEnd+1, gObjectSz, 0);
                if (sizeof(FolderInfos) == 1)
                    FixOffsets(startof(Header.resourceInfoTbl), startof(Header.resourceInfoTbl)+32, FolderInfosEnd - startof(Header.resourceInfoTbl), gObjectSz, 0);
            }
            if (RSZVersion == "RE2" || RSZVersion == "RE3" || RSZVersion == "DMC5")
                RSZFile[lvl].RSZHeader.instanceOffset = 48 + RSZFile[lvl].RSZHeader.objectCount * 4;
            
            RSZFile[lvl].RSZHeader.dataOffset += sizeToAdd - gObjectSz - newDataSize;
            
            if (RSZVersion != "RE7")
                RSZFile[lvl].RSZHeader.userdataOffset += sizeToAdd - gObjectSz - newDataSize;

            if (true) { //correct embedded UserData offsets
                i=0;
                local ushort tempLvl;
                while(exists(RSZFile[i])) {
                    Printf("lvl %i i %i\n", lvl, i);
                    if (startof(RSZFile[lvl].RSZHeader) >= startof(RSZFile[i].RSZHeader) && startof(RSZFile[lvl]) + sizeof(RSZFile[lvl]) <= startof(RSZFile[i]) + sizeof(RSZFile[i])) {
                        
                        if (exists(RSZFile[i].RSZUserDataInfos)) {
                            k=0; 
                            while((RSZVersion == "RE2" || RSZVersion == "DMC5") && exists(RSZFile[i].RSZUserDataInfos.userDataInfo[k])) {
                                tempLvl = getLevelRSZ(RSZFile[i].RSZUserDataInfos.userDataInfo[k].RSZOffset_Absolute.OffsetAbs);
                                if (exists(RSZFile[tempLvl].RSZHeader) && startof(RSZFile[lvl].InstanceInfos) > startof(RSZFile[tempLvl].RSZHeader) 
                                && startof(RSZFile[lvl].InstanceInfos) < startof(RSZFile[tempLvl]) + sizeof(RSZFile[tempLvl]))
                                    RSZFile[i].RSZUserDataInfos.userDataInfo[k].dataSize += sizeToAdd - gObjectSz - newDataSize;
                                k++;
                            }
                            FixOffsets(startof(RSZFile[i].RSZUserDataInfos), startof(RSZFile[i].RSZUserDataInfos)+sizeof(RSZFile[i].RSZUserDataInfos), 
                                startof(RSZFile[lvl].InstanceInfos) - startof(RSZFile[i].RSZHeader), sizeToAdd - gObjectSz - newDataSize * (startof(RSZFile[i].RSZHeader) == startof(RSZFile[lvl].RSZHeader)), 0);
                        }
                        if (startof(RSZFile[lvl].RSZHeader) != startof(RSZFile[i].RSZHeader))
                            FixOffsets(startof(RSZFile[i].RSZHeader), startof(RSZFile[i].RSZHeader)+sizeof(RSZFile[i].RSZHeader)+1, 
                                startof(RSZFile[lvl].InstanceInfos) - startof(RSZFile[i].RSZHeader), sizeToAdd - gObjectSz - newDataSize, 0);
                    }
                    i++;
                }
            }
            
            //correct ObjectTable etc for when an instance is inserted in the middle:
            local uint objectInsertPt, objectInsertIndex = -1;
            if (startof(RSZFile[lvl].InstanceInfos) + (instanceSize * insertIndex) < padPt) {
                for (o=0; o<RSZFile[lvl].RSZHeader.objectCount; o++) {
                    if (RSZFile[lvl].ObjectTable[o] > insertIndex) {
                        if (objectInsertPt == 0) {
                            objectInsertIndex = o;
                            objectInsertPt = startof(RSZFile[lvl].ObjectTable[o]);
                        }
                        RSZFile[lvl].ObjectTable[o] += ctr;
                    }
                }
                if (objectInsertIndex != -1) {
                    if (exists(RSZHeader.userdataCount))
                        for (o=0; o<RSZFile[lvl].RSZHeader.userdataCount; o++) 
                            if (RSZFile[lvl].RSZUserDataInfos.userDataInfo[o].instanceId >= insertIndex)
                                RSZFile[lvl].RSZUserDataInfos.userDataInfo[o].instanceId += ctr;
                    if (exists(GameObjectInfos)) 
                        for (o=0; o<Header.infoCount; o++) {
                            if (GameObjectInfos.GameObjectInfo[o].id.id >= objectInsertIndex)
                                GameObjectInfos.GameObjectInfo[o].id.id += objectCtr;
                            else if (GameObjectInfos.GameObjectInfo[o].id.id + GameObjectInfos.GameObjectInfo[o].componentCount + 1 >= objectInsertIndex)
                                GameObjectInfos.GameObjectInfo[o].componentCount += objectCtr;
                            if (GameObjectInfos.GameObjectInfo[o].parentId.id >= objectInsertIndex)
                                GameObjectInfos.GameObjectInfo[o].parentId.id += objectCtr;
                        }
                    if (exists(FolderInfos)) 
                        for (o=0; o<Header.folderCount; o++) {
                            if (FolderInfos.FolderInfo[o].id.id >= objectInsertIndex)
                                FolderInfos.FolderInfo[o].id.id += objectCtr;
                            if (FolderInfos.FolderInfo[o].parentId.id >= objectInsertIndex)
                                FolderInfos.FolderInfo[o].parentId.id += objectCtr;
                        }
                }
            } 
            
            if (objectInsertPt == 0) 
                objectInsertPt = startof(RSZFile[lvl].ObjectTable) + sizeof(RSZFile[lvl].ObjectTable);

            if (padBytes > 0)
                InsertBytes(padPt, padBytes, 0);
            if (padBytes < 0)
                DeleteBytes(padPt, -padBytes);
            
            //insert new instanceInfos
            for (i=0; i<ctr; i++) {
                InsertBytes(startof(RSZFile[lvl].InstanceInfos) + instanceSize + (insertIndex * instanceSize) + instanceSize*i, instanceSize, 0);
                tmp = SubStr(s, Arr[i], Arr[i+1] - Arr[i]);
                if (tmp[0] == 0x2A)
                    tmp = StrDel(tmp, 0, 1);
                WriteUInt(startof(RSZFile[lvl].InstanceInfos) + instanceSize + (insertIndex * instanceSize) + instanceSize*i, Atoi(tmp)); //Hash
                WriteUInt(4 + startof(RSZFile[lvl].InstanceInfos) + instanceSize + (insertIndex * instanceSize) + instanceSize*i, Atoi(StrDel(tmp, 0, findS(tmp, "_")+1))); //CRC
            }
            
            //insert new objects
            objectCtr = 0;
            for (i=0; i<ctr; i++) {
                if (s[Arr[i]] == 0x2A) {
                    InsertBytes(objectInsertPt + 4*objectCtr, 4, 0);
                    WriteUInt(objectInsertPt + 4*objectCtr, insertIndex + i + 1);
                    objectCtr++;
                }
            }
            
            RSZFile[lvl].RSZHeader.instanceOffset += objectCtr*4;
            RSZFile[lvl].RSZHeader.objectCount += objectCtr;
            RSZFile[lvl].RSZHeader.instanceCount += ctr;
            
            if (structType == 1) {
                local char buffer[gObjectSz];
                ReadBytes(buffer, GameObjectsEnd - gObjectSz, gObjectSz);
                InsertBytes(GameObjectsEnd, gObjectSz, 0);
                WriteBytes(buffer, GameObjectsEnd, gObjectSz);
                if (Header.magic == id_PFB) { //PFB
                    WriteInt(GameObjectsEnd, newId);
                    WriteInt(GameObjectsEnd+4, -1);
                    WriteInt(GameObjectsEnd+8, objectCtr - 1);
                } else {
                    for (i=0; i<4; i++)
                        WriteFloat((4*i)+GameObjectsEnd, ReadFloat((4*i)+GameObjectsEnd)*0.33); //randomize GUID
                    WriteInt(GameObjectsEnd + 16, newId);
                    WriteInt(GameObjectsEnd + 20, -1);
                    WriteShort(GameObjectsEnd + 24, objectCtr - 1);
                    WriteInt(GameObjectsEnd + 28, -1);
                }
                Header.infoCount += 1;
            }
            if (structType == 2) {
                InsertBytes(FolderInfosEnd, gObjectSz, 0);
                WriteInt(FolderInfosEnd, newId);
                WriteInt(FolderInfosEnd + 4, -1);
                Header.folderCount += 1;
            }

            if (structType > 0) 
                SetCursorPos(startof(RSZFile[0].Data.RawData)+sizeof(RSZFile[0].Data.RawData)+sizeToAdd);
            else 
                SetCursorPos(startof(RSZFile[lvl].Data.RawData.RSZ[insertIndex])+sizeof(RSZFile[lvl].Data.RawData.RSZ[insertIndex]) + sizeToAdd - newDataSize
                    - exists(RSZFile[lvl].Data.RawData.RSZ[insertIndex].skipFileData));
            
            for (i=0; i<GetNumBookmarks(); i++) 
                if (GetBookmarkName(i) == "RSZ_Data_InsertPt") 
                    RemoveBookmark(i);
            addInsertBookmark();

            Printf("Insert your new data at position %i\n", GetCursorPos());
            if (exists(newDataSize) && newDataSize > 0) {
                InsertBytes(GetCursorPos(), newDataSize, 0);
                if (stringPadOffset > -1)
                    WriteUInt(stringPadOffset, newDataPadSz / 2);
            }
            ShowRefreshMessage("Aligned RSZ Data must be pasted at the pink marker.\n");
        }
        
        void WriteNewGameObject(ubyte &d, string s) {
            if (sizeof(s) > 9 && findS(s, "_") != -1) 
                InstanceWriterMethod(s, 0, RSZFile[0].RSZHeader.instanceCount-1, true);
        }
        
        string ReadGameObjectWriter(ubyte &d) { return "      [Input a GameObjectString here to add a GameObject]"; }

        string ReadGameObjectsOffset(ubyte &o) { local string ss; SPrintf(ss, "+%i", RSZFile[0].RSZHeader.instanceCount - RSZFile[0].ObjectTable[parentof(o).id.id]); return ss; } 

        string ReadFolderInfoWriter(ubyte &f) { return "      [Input here to add a FolderInfo]"; }

        void WriteNewFolderInfo(ubyte &f, string s) { 
            local string ss;
            switch (RSZVersion) {
                case "RE7": InstanceWriterMethod(" *-1365059124_-1512238498", 0, RSZFile[0].RSZHeader.instanceCount-1, 2); break;
                case "RE2": case "RE3": case "DMC5": InstanceWriterMethod(" *-1365059124_246280887", 0, RSZFile[0].RSZHeader.instanceCount-1, 2); break;
                case "RE8": case "MHRise": InstanceWriterMethod(" *-1365059124_-1017511022", 0, RSZFile[0].RSZHeader.instanceCount-1, 2); break;
                default: break;
            }            
        }

typedef uint64 InsertKey <read=ReadInsertHashKey, write=InsertHashKey>;
     
    wstring ReadInsertHashKey(InsertKey &k) { return "      [Input CombinedKeys here to insert new Instances]      "; }
    
    void InsertHashKey(InsertKey &k, string s) {
        if (s[0] == 0x20 && sizeof(s) > 9) {
            InstanceWriterMethod(s, parentof(parentof(parentof(k))).lvl, parentof(k).index, false);
        }
    }


if (ReadUInt(0) != id_RCOL) { //no RCOL
    if (exists(Header.infoCount)) {
        struct {
            ubyte GameObjectWriter <read=ReadGameObjectWriter, write=WriteNewGameObject>; FSkip(-1);            
            for(m=0; m<Header.infoCount; m++)
                struct GObjectInfo {
                    local ushort index <hidden=false> = m;
                    if (Header.magic == id_PFB) {
                        ObjectId id(0);
                        ObjectId parentId(0);
                        int componentCount;
                    } else {
                        rGUID Guid;
                        ObjectId id(0);
                        ObjectId parentId(0);
                        ushort componentCount;
                        short ukn;
                        int prefabId;
                    }
                    FSkip(-3);
                    ubyte AddGameObjectOffset <read=ReadGameObjectsOffset>;
                    struct {
                        local ushort lvl <hidden=true> = 0;
                        n = parentof(this).index;
                        FSeek(startof(RSZFile[0].Data.RawData.RSZ[RSZFile[0].ObjectTable[parentof(this).id.id]]));
                        struct GameObject Object(0) <open=true>;
                        FSeek(startof(this)+1);
                    } GameObject <size=1>;
                    ubyte GameObjectString <read=ReadGameObjectString, write=ParseGameObjectString>;
                } GameObjectInfo <name=ReadGRefInfoName, read=ReadGRefInfo>; 
            if (!Header.infoCount) ubyte blank <hidden=true>;
        } GameObjectInfos;
        if (!Header.infoCount) 
            FSkip(-1);
    }

    if (exists(Header.folderInfoTbl)) {
        FSeek(Header.folderInfoTbl);
        struct {
            ubyte FolderInfoWriter <read=ReadFolderInfoWriter, write=WriteNewFolderInfo>; FSkip(-1);
            for (i=0; i<Header.folderCount; i++)
                struct FOLDERINFO {
                    local uint idx <hidden=true> = i;
                    ObjectId id(0);
                    ObjectId parentId(0);
                } FolderInfo <name=ReadFOLDERINFOName, read=ReadFOLDERINFO>;
            if (!Header.folderCount) ubyte blank <hidden=true>;
        } FolderInfos;
        if (!Header.folderCount) FSkip(-1);
    }
    
    if (exists(Header.userdataInfoTbl) && Header.userdataInfoTbl) {
        FSeek(Header.userdataInfoTbl);
        struct {
            ubyte UserDataInfoWriter <read=ReadNewUserDataInfoMsg, write=WriteNewUserDataInfo>; 
            if (Header.userdataCount) {
                FSkip(-1);
                UserDataInfo userDataInfo[Header.userdataCount] <optimize=false>;
            }
        } UserDataInfos;
        if (sizeof(UserDataInfos) == 1)
            FSkip(-1);
    }

    if (exists(Header.uknPFBInfoCount) && Header.uknPFBInfoCount) {
        FSeek(Header.uknPFBInfoTbl);
        struct {
	        struct {
                ObjectId InstanceID(0) <read=ReadObjectIdName>;
                ushort shortA;
                ushort shortB;
                int intA;
                ObjectId GameObjectID(0);
            } uknPFBInfo[Header.uknPFBInfoCount] <optimize=false>;
        } uknPFBInfos;
    }

    if (exists(Header.resourceInfoTbl)) {
	    FSeek(Header.resourceInfoTbl);
	    struct {
            ubyte ResourceInfoWriter <read=ReadNewResourceInfoMsg, write=WriteNewResourceInfo>; FSkip(-1);
            if (Header.resourceCount)
                Resource_Info ResourceInfo[Header.resourceCount] <optimize=false>;
            if (!Header.resourceCount) ubyte blank <hidden=true>;
	    } ResourceInfos;
        if (!Header.resourceCount) FSkip(-1);
    }
    
    if (exists(Header.prefabCount) && Header.prefabCount) {
        FSeek(Header.prefabInfoTbl);
        struct {
            ubyte PrefabInfoWriter <read=ReadNewPrefabInfoMsg, write=WriteNewPrefabInfo>; FSkip(-1);
            for (i=0; i<Header.prefabCount; i++)
                struct PreFab {
                    local uint idx <hidden=true> = i;
                    int id;
                    int parentId;
                    FSeek(id); wstring path;
                    if (parentId) {
                        FSeek(parentId); 
                        wstring parentPath;
                    }
                    FSeek(startof(parentId)+4);
                    
                } PrefabInfo <read=ReadPreFab, write=WritePreFab>;
        } PrefabInfos;
    }
}

    wstring ReadGRefInfo(GObjectInfo &g) { return ReadObjectIdTitle(g.id); }

    wstring ReadGRefInfoName(GObjectInfo &g) { return ReadObjectIdName(g.id); }

    wstring ReadFOLDERINFO(FOLDERINFO &f) { return ReadObjectIdTitle(f.id); }

    wstring ReadFOLDERINFOName(FOLDERINFO &f) { return ReadObjectIdName(f.id); }

    wstring ReadPreFab(PreFab &p) { return p.path; }

    void WritePreFab(PreFab &p, string s) { p.path = s; }

    string ReadNewResourceInfoMsg(ubyte &d) { return "      [Input a filepath here to add a ResourceInfo]"; }

    string ReadNewPrefabInfoMsg(ubyte &d) { return "      [Input a filepath here to add a PrefabInfo]"; }

    string ReadNewUserDataInfoMsg(ubyte &d) { return "      [Input a filepath here to add a UserData]"; }

    string ReadNewRSZUserDataInfoMsg(ubyte &d) { 
        if (RSZVersion != "RE2" && RSZVersion !=  "DMC5")
            return "      [Input a filepath here to add a RSZUserData]"; 
        else
            return "      [Input here to add a RSZUserData]"; 
    }
    
    void HeaderStringWriterMethod(wstring s, ubyte structType, uint lvl) {
        local uint sizeToAdd, padBytes, existingPadding, findFirst;
        local ubyte isEmbedded = (structType == 3 && RSZVersion == "RE2" || RSZVersion == "DMC5");
        local uint insertPt = startof(ResourceInfos) + sizeof(ResourceInfos) - (Header.resourceCount == 0);
        if (structType == 1)
            insertPt = startof(PrefabInfos) + sizeof(PrefabInfos) - (Header.prefabCount == 0);
        else if (structType == 2)
            insertPt = startof(UserDataInfos) + sizeof(UserDataInfos) - (Header.userdataCount == 0);
        
        local uint stringInsertPt = insertPt;
        local uint stringSizeToAdd = sizeof(s)-2;
        local uint startBound = startof(ResourceInfos);
        local uint endBound = startof(ResourceInfos)+sizeof(ResourceInfos)-(sizeof(ResourceInfos)==1);
        
        if (structType == 3) { //RSZUserData
            startBound = startof(RSZFile[lvl].RSZHeader);
            insertPt = startof(RSZFile[lvl].RSZUserDataInfos) + sizeof(RSZFile[lvl].RSZUserDataInfos) - (sizeof(RSZFile[lvl].RSZUserDataInfos) == 1) ;
            if (RSZVersion != "RE2" && RSZVersion != "DMC5" && exists(RSZFile[lvl].RSZUserDataInfos.userDataInfo.path.String) 
              && startof(RSZFile[lvl].RSZUserDataInfos.userDataInfo.path.String) + sizeof(RSZFile[lvl].RSZUserDataInfos.userDataInfo.path.String) > stringInsertPt)
                stringInsertPt = startof(RSZFile[lvl].RSZUserDataInfos.userDataInfo.path.String) + sizeof(RSZFile[lvl].RSZUserDataInfos.userDataInfo.path.String);
            else 
                stringInsertPt = insertPt;
        } else {
            while(!detectedString(stringInsertPt) && stringInsertPt < RSZOffset)
                stringInsertPt++;
            while(detectedString(stringInsertPt))
                stringInsertPt += sizeof(ReadWString(stringInsertPt));
        }
        
        endBound = stringInsertPt;
        if (structType != 0 || exists(ResourceInfos.ResourceInfo.pathStr.strOffset) ) { //SCN || (Header.magic == id_SCN && Header.resourceCount == 0)
            (ReadInt64(insertPt) != 0 || structType >= 2) ? sizeToAdd = 16 : sizeToAdd = 0;
            if (isEmbedded) {
                sizeToAdd = 24;
                stringSizeToAdd = 0;
                stringInsertPt = insertPt;
                while(ReadByte(insertPt + existingPadding) == 0) 
                    existingPadding++;
                while ((insertPt + sizeToAdd + padBytes) % 16 != insertPt % 16 )
                    padBytes++;
                if (existingPadding + padBytes > 16)
                    padBytes -= 16;
                sizeToAdd += padBytes;
            } else {
                while(ReadByte(stringInsertPt + existingPadding) == 0) 
                    existingPadding++;
                while ((stringInsertPt + stringSizeToAdd + padBytes) % 16 != stringInsertPt % 16 )
                    padBytes++;
                if (existingPadding + padBytes > 16)
                    padBytes -= 16;
                stringSizeToAdd += padBytes;
            }
            
            //Printf("%i %i %i %i %i\n%i %i\n", insertPt, stringInsertPt, sizeToAdd, padBytes, existingPadding, startBound, stringSizeToAdd);
            if (structType == 3) {
                FixOffsets(startBound, endBound, insertPt - startBound, sizeToAdd, 0);
                FixOffsets(startBound, endBound, stringInsertPt - startBound, stringSizeToAdd, 0);
                FixOffsets(startof(RSZFile[lvl].RSZUserDataInfos), endBound, insertPt - startBound, sizeToAdd, 0);
                FixOffsets(startof(RSZFile[lvl].RSZUserDataInfos), endBound, stringInsertPt - startBound, stringSizeToAdd, 0);
            } else {
                FixOffsets(0, startof(GameObjectInfos), insertPt, sizeToAdd, 0);
                FixOffsets(0, startof(GameObjectInfos), stringInsertPt, stringSizeToAdd, 0);
                FixOffsets(startBound, endBound, insertPt, sizeToAdd, 1);
                FixOffsets(startBound, endBound, stringInsertPt, sizeToAdd + stringSizeToAdd, 1);
            }
            if (stringSizeToAdd > 0) { 
                InsertBytes(stringInsertPt, stringSizeToAdd, 0);
                WriteWString(stringInsertPt, s);
            }
            
            if (sizeToAdd > 0)
                InsertBytes(insertPt, sizeToAdd, 0);
            if (structType == 3) {
                if (isEmbedded) {
                    while(FileSize()%16 != 0) 
                        InsertBytes(FileSize(), 1, 0);
                    WriteInt64(insertPt + 8 + (8 * isEmbedded), FileSize() - startof(RSZFile[lvl].RSZHeader));
                    SetCursorPos(FileSize());
                    addInsertBookmark();
                } else {
                    WriteInt64(insertPt + 8, stringInsertPt + sizeToAdd - startof(RSZFile[lvl].RSZHeader));
                }
            } else if (structType == 2) {
                WriteInt64(insertPt + 8, stringInsertPt + sizeToAdd);
            } else
                WriteInt64(insertPt, stringInsertPt + sizeToAdd);
            //for (j=0; j<Header.resourceCount; j++) {
            //    findFirst = FindFirst(ResourceInfos.ResourceInfo[j].pathStr._String);
            //    if (findFirst > -1)
            //        WriteInt64(startof(ResourceInfos.ResourceInfo[j]), findFirst);
            //}
        } else { 
            while ((insertPt + stringSizeToAdd + padBytes) % 16 != insertPt % 16 )
                padBytes++;
            stringSizeToAdd += padBytes;
            FixOffsets(0, startof(GameObjectInfos), insertPt, stringSizeToAdd, 0);
            InsertBytes(insertPt, stringSizeToAdd, 0);
            WriteWString(insertPt, s);
        } 
        
        if (structType == 0) //ResourceInfo
            Header.resourceCount += 1;
        else if (structType == 1) //PrefabInfo
            Header.prefabCount += 1;
        else if (structType == 2) //UserDataInfo
            Header.userdataCount += 1;
        else if (structType == 3) //RSZUserDataInfo
            RSZFile[lvl].RSZHeader.userdataCount += 1;
        
        if (structType == 3) { //For RSZUserdataInfo, write the header's UserDataInfo to match
            if (exists(UserDataInfos.UserDataInfoWriter))
                WriteNewUserDataInfo(UserDataInfos.UserDataInfoWriter, s);
            if (isEmbedded)
                ShowRefreshMessage("An Embedded UserData must be pasted at the pink marker, and an InstanceInfo must be added for it and set up in UserDataInfos.\n");
            else
                ShowRefreshMessage("A UserData-linking InstanceInfo must be added and then used with this struct.\n");
        } else if (structType != 2)
            ShowRefreshMessage("");
    }

    void WriteNewResourceInfo(ubyte &d, wstring s) { HeaderStringWriterMethod(s, 0, 0); }

    void WriteNewPrefabInfo(ubyte &p, wstring s) { HeaderStringWriterMethod(s, 1, 0); }

    void WriteNewUserDataInfo(ubyte &u, wstring s) { 
        //if (MessageBox(idOk | idCancel, "Insert Data", "Warning: You should insert a RSZUserDataInfo with this") == idOk)
        HeaderStringWriterMethod(s, 2, 0); 
    }

    void WriteNewRSZUserDataInfo(ubyte &r, wstring s) { HeaderStringWriterMethod(s, 3, parentof(parentof(r)).lvl); }

typedef struct {
    local ushort lvl <hidden=true>;
    if (exists(parentof(this).lvl)) 
        lvl = parentof(this).lvl;
    else lvl = getLevelRSZ(FTell());
    uint instanceId; 
    HASH typeId <read=ReadHASHWithName>;   
    if (RSZVersion == "DMC5" || RSZVersion == "RE2") {
        uint JsonPathHash;
        uint dataSize;
        uint64 RSZOffset <hidden=true>;
        FSkip(-8);
        struct AbsOffset RSZOffset_Absolute(startof(RSZHeader), 8) <name="RSZOffset">;
        FSkip(-1); struct { ubyte a; local wstring String; } path <hidden=true>; //dummy
        if (RSZOffset_Absolute.OffsetAbs < FileSize() && ReadUInt(RSZOffset_Absolute.OffsetAbs) == 5919570) {
            FSeek(RSZOffset_Absolute.OffsetAbs); 
            struct  {
                struct RSZMagic UserData <open=true>;
                checkUseSpacers();
            } Embedded_UserData <size=52>;
            FSeek(startof(RSZOffset)+8);
        } else
            Printf("UserData not found at RSZ[%i] RSZUserData[%i]\n", lvl, (startof(this) - startof(parentof(this))) / 24);
    } else {
        StringRead path(-1, startof(RSZHeader), 0); 
    }
} RSZUserDataInfo <name=ReadRSZUserDataInfoName, read=ReadRSZUserDataInfo>;

    string ReadRSZUserDataInfoName(RSZUserDataInfo &u) { 
        local string s; 
        if (u.instanceId > -1 && u.lvl > -1 && exists(RSZFile[u.lvl].InstanceInfos.instanceInfo[u.instanceId]))
            SPrintf(s, "%s[%i] ", RSZFile[u.lvl].InstanceInfos.instanceInfo[u.instanceId].typeId.HashName, u.instanceId);
        return s;
    }
    
    string ReadRSZUserDataInfo(RSZUserDataInfo &u) {  
        if (exists(u.uknHash))
            return ReadRSZMagicName(RSZFile[getLevelRSZ(u.RSZOffset_Absolute.OffsetAbs)]);
        else 
            return u.path.String; 
    }

typedef struct(ubyte isFolder)
{
    local ushort lvl <hidden=true>;
    local int tempN <hidden=true>, tempJ <hidden=true>, prefabCount <hidden=true>, 
           gChildCount <hidden=true>, fChildCount <hidden=true>, id <hidden=true>;
    
    if (exists(parentof(this).lvl)) 
        lvl = parentof(this).lvl;
    else 
        lvl = getLevel(FTell());
    
    local wstring title <hidden=true>;
    isFolder == true ? (id = FolderInfos.FolderInfo[n].id.id) : (id = GameObjectInfos.GameObjectInfo[n].id.id);
    
    if (!isFolder && exists(GameObjectInfos.GameObjectInfo[n].prefabId) && GameObjectInfos.GameObjectInfo[n].prefabId != -1) {
        StringRead Prefab(startof(PrefabInfos.PrefabInfo[GameObjectInfos.GameObjectInfo[n].prefabId].id), 0, 0) <open=suppress, name=PrefabName>; 
        FSkip(-1);
        title = Prefab.String;
    }
    
    if (exists(Header.prefabCount) && Header.prefabCount) {
        for (j=0; j<Header.prefabCount; j++)
            if (PrefabInfos.PrefabInfo[j].parentId == id)
                prefabCount++;
        if (prefabCount) {
            struct {
                for (j=0; j<Header.prefabCount; j++)
                    if (PrefabInfos.PrefabInfo[j].parentId == id) {
                        StringRead Prefab(startof(PrefabInfos.PrefabInfo[j]), 0, 0) <open=suppress, name="Prefab">;
                        FSkip(-1);
                    }
                FSeek(startof(this) + 1);
            } Prefabs <name="Child Prefabs">;
            FSkip(-1);
        }
    }

    local uint counter <hidden=true>, componentCount <hidden=true>;
    if (!isFolder)
        componentCount = GameObjectInfos.GameObjectInfo[n].componentCount;
    for (counter=id; counter<id+1+componentCount; counter++) {
        if (exists(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[counter]])) {
            i = RSZFile[lvl].ObjectTable[counter];
            tempN = n;
            FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[counter]]));
            struct RSZInstance RSZ;
            n = tempN;
        }
    }
    
    if (title == "" && exists(RSZ[0].title))
        title = RSZ[0].title; 
        
    if (exists(Header.folderCount)) {        
        for (j=0; j<Header.folderCount; j++)
            if (FolderInfos.FolderInfo[j].parentId.id == id && exists(ObjectTable[FolderInfos.FolderInfo[j].id.id])) {
                if (!fChildCount)
                    FSeek(startof(RawData.RSZ[ObjectTable[FolderInfos.FolderInfo[j].id.id]]));
                fChildCount++;
            }
        
        if (fChildCount) {
            struct {
                for (j=0; j<Header.folderCount; j++) {
                    if (FolderInfos.FolderInfo[j].parentId.id == id) {
                        tempN = n; tempJ = j;
                        FSeek(startof(RawData.RSZ[ObjectTable[FolderInfos.FolderInfo[j].id.id]]));
                        n = j;
                        if (fChildCount == 1)
                            struct GameObject ChildFolder(1) <read=ReadGameObject, open=true>;
                        else
                            struct GameObject ChildFolder(1) <read=ReadGameObject>;
                        n = tempN; j = tempJ;
                    }
                }
                if (startof(this) > FTell())
                    FSeek(startof(this) + sizeof(ChildFolder[0]));
            } Folders <name="Child Folders">;
        }
    }
    
    for (j=0; j<Header.infoCount; j++)
        if (GameObjectInfos.GameObjectInfo[j].parentId.id == id ) {
            if (!gChildCount && exists(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[GameObjectInfos.GameObjectInfo[j].id.id]]))
                FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[GameObjectInfos.GameObjectInfo[j].id.id]]));
            gChildCount++;
        }    
    
    if (gChildCount) {
        struct {
            for (j=0; j<Header.infoCount; j++) {
                if (GameObjectInfos.GameObjectInfo[j].parentId.id == id && exists(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[GameObjectInfos.GameObjectInfo[j].id.id]])) {
                    tempN = n; tempJ = j;
                    FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[GameObjectInfos.GameObjectInfo[j].id.id]]));
                    n = j;
                    if (gChildCount == 1)
                        struct GameObject ChildObject(0) <open=true>;
                    else
                        struct GameObject ChildObject(0);
                    n = tempN; j = tempJ;
                }
            }
            if (startof(this) > FTell())
                FSeek(startof(this) + sizeof(ChildObject[0]));
        } GameObjects <name="Child GameObjects">;
    }
    
    checkUseSpacers();
    
    if (startof(this) > FTell())
        FSeek(startof(this) + sizeof(RSZ[0]));
} GameObject <name=ReadGameObjectName, read=ReadGameObject>;;

    wstring ReadGameObjectName(GameObject &g) {         
        return ReadRSZInstanceName(g.RSZ[0]);
    }

    wstring ReadGameObject(GameObject &g) {
        local wstring s;
        if (exists(g.RSZ[0].var[0].data)) {
            s = (wstring)g.RSZ[0].var[0].data;
            if (exists(g.RSZ[0].var[5].size ) && exists(g.RSZ[0].var[5].data) && g.RSZ[0].var[5].data != "" && g.RSZ[0].name == "via.Folder")
                s += "  :  " + g.RSZ[0].var[5].data + "";
            else if (exists(g.RSZ[0].var[0].size ) && exists(g.RSZ[0].var[1].data ) && g.RSZ[0].var[1].data != "" && g.RSZ[0].name == "via.GameObject")
                s += " (" + g.RSZ[0].var[1].data + ")";
        }
        return s;
    }

typedef struct (uint relStart, ubyte dataSize) {
    if (dataSize == 4)
        uint offset;
    else
        uint64 offset;
    local uint Relative_Start = relStart;
    local uint OffsetAbs <hidden=true> = relStart + offset;
} AbsOffset <read=ReadAbsoluteOffset, write=WriteAbsoluteOffset>;

    string ReadAbsoluteOffset (AbsOffset &a) {
        local string ss;
        SPrintf(ss, "%i", a.Relative_Start + a.offset);
        return ss;
    }
    
    void WriteAbsoluteOffset(AbsOffset &a, string s) {
        if (Atoi(s) >= a.Relative_Start)
            a.offset = Atoi(s) - a.Relative_Start;
    }

typedef struct {
    
    if (realStart != -1) {
        FSeek(realStart);
        realStart = -1;
    }
    
    typedef struct {
	    uint magic;
	    uint version;
	    int objectCount;
	    int instanceCount;
        if (RSZVersion != "RE7") {
	        int userdataCount;
	        int reserved <hidden=true>;
        }
        int64 instanceOffset <hidden=true>;
        FSkip(-8);
        struct AbsOffset instanceOffset_Absolute(startof(this), 8) <name="instanceOffset">;
	    int64 dataOffset <hidden=true>;
        FSkip(-8);
        struct AbsOffset dataOffset_Absolute(startof(this), 8) <name="dataOffset">;
        if (RSZVersion != "RE7") {
	        int64 userdataOffset <hidden=true>;
            FSkip(-8);
            struct AbsOffset userdataOffset_Absolute(startof(this), 8) <name="userdataOffset">;
        }
        local uint AbsoluteDataOffs <hidden=true> = dataOffset + startof(this);
        if (startof(this) != startof(parentof(this)))
            local uint TotalSize;
    } RSZHEADER <name="RSZHeader">;

    if (!ShowChildRSZs && exists(parentof(this)) && !exists(offset))
        struct RSZHEADER RSZHeader <hidden=true>;
    else 
        struct RSZHEADER RSZHeader;
    
    local ushort lvl <hidden=true> = getLevel(RSZHeader.AbsoluteDataOffs);
    if (RSZVersion != "RE7") 
        FSeek(startof(RSZHeader.userdataOffset)+8);
    if (RSZHeader.objectCount && !ShowChildRSZs && exists(parentof(this)) && !exists(offset))
        int ObjectTable[RSZHeader.objectCount] <hidden=true, name=ReadObjectName, read=ReadObject>;
    else if (RSZHeader.objectCount)
        int ObjectTable[RSZHeader.objectCount] <name=ReadObjectName, read=ReadObject>;
    
    if (RSZVersion != "RE7")
        FSeek(startof(RSZHeader) + RSZHeader.instanceOffset);
    
    typedef struct {
        for (i=0; i< RSZHeader.instanceCount; i++) {
            struct InstanceInfo {
                local uint index <hidden=true> = i;
	            HASH typeId;
                uint CRC;
                FSkip(-8);
                int64 CombinedKey <read=ReadCombinedKey>;
                FSkip(-8);
                InsertKey NewKey;
                local ubyte isObject <hidden=true>;
                if (!i)
                    typeId.HashName = "NULL";
                if (RSZVersion == "RE7")
                    FSkip(8);
            } instanceInfo <name=ReadInstanceInfoName, read=ReadInstanceInfo>;
        }
        for (j=0; j<RSZHeader.objectCount ; j++) 
            if (exists(instanceInfo[ObjectTable[j]]))
                instanceInfo[ObjectTable[j]].isObject = true;
    } INSTANCEINFO <name="InstanceInfos">;
    
    if (!ShowChildRSZs && (exists(parentof(this)) && !exists(offset)))
        INSTANCEINFO InstanceInfos <hidden=true>;
    else 
        INSTANCEINFO InstanceInfos;
    
    if (RSZVersion != "RE7" && exists(RSZHeader.userdataOffset)) {
	    FSeek(startof(RSZHeader) + RSZHeader.userdataOffset);
        typedef struct {
            ubyte RSZUserDataInfoWriter <read=ReadNewRSZUserDataInfoMsg, write=WriteNewRSZUserDataInfo>; 
            if (RSZHeader.userdataCount) {
                FSkip(-1);
                for (i=0; i<RSZHeader.userdataCount; i++)
                    RSZUserDataInfo userDataInfo;
            }
        } RSZUSERDATAINFOS <name="RSZUserDataInfos">;
        
        if (!ShowChildRSZs && (exists(parentof(this)) && !exists(offset)))
            struct RSZUSERDATAINFOS RSZUserDataInfos <hidden=true>;
        else 
            struct RSZUSERDATAINFOS RSZUserDataInfos;
        if (sizeof(RSZUserDataInfos) == 1)
            FSkip(-1);
    }
    
    local ubyte isUserData <hidden=true>;
    
    FSeek(RSZHeader.AbsoluteDataOffs);
    if (RSZHeader.instanceCount > 1) {
        struct {
            local ubyte isObject <hidden=true>;
            local ushort lvl <hidden=true> = parentof(this).lvl;
            typedef struct { 
                if (!IsInitialized())
                    ParseJson(JsonPath);
                local int temp <hidden=true>;
                local uint maxDivs <hidden=true> = RSZFile[lvl].RSZHeader.instanceCount / 100 + 1;
                local uint waypoints[maxDivs] <hidden=true>; 
                local uint divCounter <hidden=true>;
                local int lvl <hidden=true> = getLevel(FTell());
                
                for (i=0; i<RSZFile[lvl].RSZHeader.instanceCount; i++) {
                    
                    if (RSZVersion != "RE7" && !finished && RSZFile[lvl].InstanceInfos.instanceInfo[i].typeId.HashName == "via.GameObject") 
                    {
                        if (FTell()+4 <= FileSize())
                            fakeGameObject();//fakeGameObject Test <hidden=true>;
                        temp = FTell();
                        if (lastGameObject > 0 && (ReadUInt(FTell()-4) != 3212836864 )) { //Test.timeScale
                            Printf("Seeking from %u to last GameObject at %u\n",  FTell(), lastGameObject); 
                            FSeek(temp);
                            BLANK blank <read=ReadErrorNotice, bgcolor=cRed>;
                            FSeek(lastGameObject);
                            while (FTell() <= FileSize() - 8) {
                                if (ReadUInt(FTell()) == 3212836864 && detectedBools(FTell()-4) 
                                && (detectedString(FTell()-16) || detectedString(FTell()-20) || detectedString(FTell()-24)) )
                                    break;
                                FSkip(4);
                            }
                            lastGameObject = FTell()+4;
                            Printf("Redetected next GameObject at %u\n",  lastGameObject); 
                            FSkip(-32);
                            if (detectedString(FTell()))
                                redetectStringBehind();
                            else FSkip(8);
                            broken = false;
                            SetForeColor(cYellow);
                        } else if (FTell() > lastGameObject) {
                            lastGameObject = FTell();
                            FSeek(temp);
                            SetForeColor(cNone);
                        }
                    }
                    temp = FTell();
                    if (GetFieldArrayState(RSZFile[lvl].InstanceInfos.instanceInfo[i].typeId.Hash, 0))
                        FSeek(getAlignedOffset(FTell(), 4));
                    else
                        FSeek(getAlignedOffset(FTell(), GetFieldAlignment(RSZFile[lvl].InstanceInfos.instanceInfo[i].typeId.Hash, 0))); 
                    
                    //Set waypoint for reader, dividing the list up for quicker scanning:
                    if (i == 100 * divCounter) {
                        waypoints[divCounter] = FTell();
                        divCounter++;
                    }
                    
                    if (!i) {
                        struct RSZInstance RSZ <hidden=true>;
                    } else
                        struct RSZInstance RSZ;
                    
                    if (sizeof(RSZ) == 0) 
                        Printf("Empty struct: %u\n", FTell()); 
                    if (exists(RSZ.skipFileData) || i == 0) {
                        FSeek(temp);
                    } else if (exists(RSZ.skip)) {
                        if (i)
                            Printf("\nERROR: Missing struct for %X %s [%u]\n", RSZ.hash, RSZ.name, RSZ.idx);
                        FSeek(temp);
                    }
                }
            } DATA <name="RawData">;
            SetForeColor(cNone);
            if (HideRawData  || (!ShowChildRSZs && (!exists(offset) && exists(parentof(parentof(parentof(this))))))) //if is an embedded RSZMagic
                struct DATA RawData <hidden=false, open=suppress>;
            else
                struct DATA RawData <open=suppress>;

            SetForeColor(cNone);
            finished = TRUE;

            isUserData = false;
            if (RSZHeader.objectCount > 0 && Header.magic == 5395285 || findS(ReadObject(ObjectTable[RSZHeader.objectCount-1]), "assets:") != -1 )
                isUserData = true;

            if (Nesting && (Header.magic != id_RCOL && Header.magic != id_BHVT && Header.magic != id_BHVT) ) { //no RCOL, MFS2 or BHVT
                if (exists(Header.dataOffset) && startof(RSZFile[lvl].RSZHeader) == Header.dataOffset ) {
                    local ushort n <hidden=true>;
                    if (exists(Header.folderCount))
                        for (n=0; n<Header.folderCount; n++) {
                            if (FolderInfos.FolderInfo[n].parentId.id == -1 && exists(RawData.RSZ[ObjectTable[FolderInfos.FolderInfo[n].id.id]])) { 
                                FSeek(startof(RawData.RSZ[ObjectTable[FolderInfos.FolderInfo[n].id.id]]));
                                struct GameObject MainFolder(1)  <name=ReadGameObjectName, read=ReadGameObject>;
                            }
                        }
                    if (exists(Header.infoCount))
                        for (n=0; n<Header.infoCount; n++) {
                            if (GameObjectInfos.GameObjectInfo[n].id.id > -1 && GameObjectInfos.GameObjectInfo[n].parentId.id == -1 && exists(RawData.RSZ[ObjectTable[GameObjectInfos.GameObjectInfo[n].id.id]])) { 
                                FSeek(startof(RawData.RSZ[ObjectTable[GameObjectInfos.GameObjectInfo[n].id.id]]));
                                struct GameObject MainObject(0)  <name=ReadGameObjectName, read=ReadGameObject>;
                            } 
                        }
                }
                
                if ((!exists(this.MainObject) && !exists(this.MainFolder))) {
                    for (i=1; i<RSZHeader.instanceCount; i++) {
                        if (exists(RawData.RSZ[i])) {
                            isObject = InstanceInfos.instanceInfo[i].isObject; 
                            if (isObject) {
                                FSeek(startof(RawData.RSZ[i]));
                                if (RSZHeader.objectCount == 1) {
                                    struct RSZInstance RSZ <open=true>;
                                    checkUseSpacers();
                                } else 
                                    struct RSZInstance RSZ;
                                if (exists(RawData.RSZ[i].skip) || exists(RawData.RSZ[i].skipFileData)) 
                                    FSeek(startof(RSZ));
                            }
                        }
                    }
                }
            }
            FSeek(startof(RawData) + sizeof(RawData));
            SetForeColor(cNone);
        } Data <name="Data", open=true>;
    } else 
        { FSkip(-1); ubyte Data <hidden=true>; }
    
    if (exists(parentof(this)))
        checkUseSpacers();
    
    local int f <hidden=true>, ff <hidden=true>;
    if (ShowChildRSZs && (RSZHeader.userdataCount && (RSZVersion == "DMC5" || RSZVersion == "RE2")) ) {
        FSeek(RSZUserDataInfos.userDataInfo[0].RSZOffset_Absolute.OffsetAbs);
        struct {
            for (f=0; f<RSZHeader.userdataCount; f++) {
                FSeek(RSZUserDataInfos.userDataInfo[f].RSZOffset_Absolute.OffsetAbs);
                struct RSZMagic UserData <size=SizeRSZMagic, fgcolor=cNone>;
            }
        } UserData;
    }
    FSeek(startof(Data)+sizeof(Data));
    if (exists(this.RSZHeader.TotalSize))
        this.RSZHeader.TotalSize = FTell()-startof(RSZHeader);
} RSZMagic <name="RSZ", name=ReadRSZMagicName, read=ReadRSZMagic>;
    
    wstring ReadRSZMagicName(RSZMagic &m) { 
        if (exists(m.ObjectTable) && m.ObjectTable[0] >= 0 && exists(m.InstanceInfos.instanceInfo[m.ObjectTable[0]].typeId.HashName)) {
            return m.InstanceInfos.instanceInfo[m.ObjectTable[0]].typeId.HashName; 
        } else {
            local uint f;
            for (f=0; f<level; f++) {
                if (startof(RSZFile[f].RSZHeader) == startof(m) && exists(RSZFile[f].ObjectTable) && RSZFile[f].ObjectTable[0] >= 0 && exists(RSZFile[f].InstanceInfos.instanceInfo[RSZFile[f].ObjectTable[0]].typeId.HashName) ) 
                    return RSZFile[f].InstanceInfos.instanceInfo[RSZFile[f].ObjectTable[0]].typeId.HashName;
            }
        }
        return "RSZ"; 
    }

    wstring ReadRSZMagic(RSZMagic &m) { 
        if (exists(m.Data.RSZ[0].title)) 
            return m.Data.RSZ[0].title;
        else if (exists(m.Data.MainObject[0].title))
            return m.Data.MainObject[0].title;
        else if (exists(m.Data.MainFolder[0].title))
            return m.Data.MainFolder[0].title;
        else {
            local uint f;
            for (f=0; f<level; f++) {
                if (startof(RSZFile[f].RSZHeader) == startof(m) && exists(RSZFile[f].ObjectTable) && RSZFile[f].ObjectTable[0] >= 0 && exists(RSZFile[f].Data.RawData.RSZ[RSZFile[f].ObjectTable[0]].title) ) 
                    return RSZFile[f].Data.RawData.RSZ[RSZFile[f].ObjectTable[0]].title;
            }
        }
        return ""; 
    }

    int SizeRSZMagic(RSZMagic &r) {
        if (finished) {
            local uint f;
            for (f=0; f<level; f++) {
                if (startof(RSZFile[f].RSZHeader) == startof(r)) 
                    return sizeof(RSZFile[f]);
            }
        } return 52;
    }

    wstring ReadObjectName(int &o) { 
        local ushort lvl = parentof(o).lvl;
        if (startof(RSZFile[lvl].RSZHeader) + RSZFile[lvl].RSZHeader.instanceOffset + (8*(1+(RSZVersion=="RE7"))) * o <= FileSize()-4) {
            local uint hash = ReadUInt((startof(RSZFile[lvl].RSZHeader) + RSZFile[lvl].RSZHeader.instanceOffset + (8*(1+(RSZVersion=="RE7"))) * o));
            return ReadHashName(hash); 
        }
        return "";
    }

    wstring ReadObject(int &o) { 
        local ushort lvl = parentof(o).lvl;
        local string s;
        if (exists(RSZFile[lvl].Data.RawData.RSZ[o])) {
            SPrintf(s, "%i -- ", o);
            return s +  RSZFile[lvl].Data.RawData.RSZ[o].title;
        } return "";
    }

    string ReadInstanceInfoName(InstanceInfo &i) { if (i.isObject) return "*" + i.typeId.HashName;  return i.typeId.HashName;}
    
    string ReadInstanceInfo(InstanceInfo &i) { string s; SPrintf(s, "%X", i.typeId.Hash); return s; }

    string ReadCombinedKey(int64 &k) {
        local string ss = " ";
        if (parentof(k).isObject) ss+="*";
        SPrintf(ss,"%s%i_%i", ss, parentof(k).typeId.Hash, parentof(k).CRC);
        return ss;
    }


enum BHVTlvl {
    id_All = -1,
    id_Actions = 0,
    id_Selectors = 1,
    id_SelectorCallers = 2,
    id_Conditions = 3,
    id_transitionEvents = 4,
    id_expressionTreeConditions = 5,
    id_staticActions = 6,
    id_staticSelectorCallers = 7,
    id_staticConditions = 8,
    id_staticTransitionEvents = 9,
    id_staticExpressionTreeConditions = 10,
    id_TransitionId = 11,
    id_Paths = 12,
    id_Tags
};

int getBHVTLevel(BHVTlvl lv) {
    local byte ret;
    switch (lv) {
        case 0: ret = getLevelRSZ(Header.BHVT.actionOffset+BHVTOffset); break;
        case 1: ret = getLevelRSZ(Header.BHVT.selectorOffset+BHVTOffset); break;
        case 2: ret = getLevelRSZ(Header.BHVT.selectorCallerOffset+BHVTOffset); break;
        case 3: ret = getLevelRSZ(Header.BHVT.conditionsOffset+BHVTOffset); break;
        case 4: ret = getLevelRSZ(Header.BHVT.transitionEventOffset+BHVTOffset); break;
        case 5: ret = getLevelRSZ(Header.BHVT.expressionTreeConditionsOffset+BHVTOffset); break;
        case 6: ret = getLevelRSZ(Header.BHVT.staticActionOffset+BHVTOffset); break;
        case 7: ret = getLevelRSZ(Header.BHVT.staticSelectorCallerOffset+BHVTOffset); break;
        case 8: ret = getLevelRSZ(Header.BHVT.staticConditionsOffset+BHVTOffset); break;
        case 9: ret = getLevelRSZ(Header.BHVT.staticTransitionEventOffset+BHVTOffset); break;
        case 10: ret = getLevelRSZ(Header.BHVT.staticExpressionTreeConditionsOffset+BHVTOffset); break;
        default: ret = -1; break;
    }
    return ret;
}

typedef struct(BHVTlvl lv, ubyte isList) {
    local BHVTlvl lv <hidden=true> = lv;
    if (isList) {
        struct BHVTCount Count(1);
        if (Count.Count == 1) { 
            struct BHVTId ID(lv, 0) <open=true>; 
            checkUseSpacers(); 
        } else if (Count.Count) 
            struct { 
                struct BHVTId ID(lv, 0)[Count.Count]; 
            } IDs;
    } else {
        if (ReadUByte(FTell()+2) == 0) {
            int id : 16;
            int ukn : 8;
            int ukn2 : 8;
        } else 
            int id;
        
        if (finished && id > -1) {
            local short lvl <hidden=true> = getBHVTLevel(lv);
            if (lvl > -1 && exists(RSZFile[lvl].ObjectTable[id]) && exists(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[id]])) { //
                FSeek(startof(RSZFile[lvl].Data.RawData.RSZ[RSZFile[lvl].ObjectTable[id]]));
                local ushort RSZIdx <hidden=true> = (uint)RSZFile[lvl].ObjectTable[id];
                struct RSZInstance RSZ <open=true>;  //

                if (exists(Header.BHVT.Uvar)) {
                    local int vr <hidden=true>;
                    while (exists(RSZ.var[vr])) {
                        if (exists(RSZ.var[vr].Guid.uuid) && ReadUInt(startof(RSZ.var[vr].Guid)) != 0) {
                            break;
                        } vr++;
                    }
                    if (exists(RSZ.var[vr].Guid.uuid)) {
                        local int uv <hidden=true>, vd <hidden=true>;
                        while (exists(Header.BHVT.Uvar[uv])) {
                            if (exists(Header.BHVT.Uvar[uv].start)) 
                                start = Header.BHVT.Uvar[uv].start;
                            for (i=0; i<Header.BHVT.Uvar[uv].Header.variableCount; i++) {
                                if (Header.BHVT.Uvar[uv].HashData.GUIDs.GUIDs[i].uuid == RSZ.var[vr].Guid.uuid) {
                                    FSeek(startof(Header.BHVT.Uvar[uv].Data.Var[Header.BHVT.Uvar[uv].HashData.dataHashMap[i]]));
                                    struct UVARIABLE Uvariable <open=true>;
                                    break;
                                }
                            }
                            uv++;
                            if (exists(Uvariable)) 
                                break;
                        }
                        if (!exists(Uvariable)) {
                            struct {
                                uv = 0;
                                while (exists(Header.BHVT.Uvar[uv])) {
                                    for (i=0; i<Header.BHVT.Uvar[uv].Header.variableCount; i++) {
                                        if (exists(Header.BHVT.Uvar[uv].Data.Var[i].VarData)) {
                                            for (vd=0; vd<Header.BHVT.Uvar[uv].Data.Var[i].VarData.propCount; vd++) {
                                                if (exists(Header.BHVT.Uvar[uv].Data.Var[i].VarData.Node[vd].Value.value.uuid) && Header.BHVT.Uvar[uv].Data.Var[i].VarData.Node[vd].Value.value.uuid == RSZ.var[3].Guid.uuid) {
                                                    FSeek(startof(Header.BHVT.Uvar[uv].Data.Var[i]));
                                                    struct UVARIABLE UvarRef;
                                                }
                                            }
                                        }
                                    }
                                    uv++;
                                }
                                checkUseSpacers();
                            } VariableRefs <open=true>;
                        }
                    }
                    checkUseSpacers();
                }
            } else if (exists(Header.TransitionMap[id])) {
                FSeek(startof(Header.TransitionMap[id]));
                struct TRANSITIONMAP TransitionMap <open=true>;
                checkUseSpacers();
            } 
            FSeek(startof(id)+4);
        }
    }
} BHVTId <open=suppress, optimize=false, read=ReadBHVTId, write=WriteBHVTId>;

    wstring ReadBHVTId(BHVTId &i) { 
        string s;
        if (exists(i.id)) {
            if (exists(i.RSZ)) 
                return ReadRSZInstanceName(i.RSZ); 
            SPrintf(s, "%i", i.id);
        } else if (i.Count.Count > 0 && exists(i.ID))
            return ReadBHVTId(i.ID); 
        else SPrintf(s, "%i", i.Count.Count);
        return s;
    } 

    void WriteBHVTId(BHVTId &i, string s) { WriteInt(startof(i), Atoi(s)); } 

typedef struct(BHVTlvl lv) {
    local BHVTlvl lv <hidden=true> = lv;
    TagsCollection hash <format=hex>;
    if (finished && hash != -1 && hash != 0) {
        local short lvl <hidden=true> = getBHVTLevel(lv);
        if (lv == id_TransitionId) {
            if (detectedStringSm(startof(Header.BHVT.mPathNamePool) + 8 + hash * 2) && sizeof(ReadWString(startof(Header.BHVT.mPathNamePool) + 8 + hash * 2)) > 10) {
                struct StringRead Path(-1, startof(Header.BHVT.mPathNamePool) + 8 + hash * 2, -1);
            } else {
                m=0;
                while(exists(Header.TransitionMap[m])) {
                    if (Header.TransitionMap[m].transitionId == hash) {
                        FSeek(startof(Header.TransitionMap[m]));
                        struct TRANSITIONMAP TransitionMap <open=true>;
                        break;   
                    }
                    m++;
                }
            }
        } else if (detectedHash(startof(hash))) {
            
            local int kk <hidden=true>, tg <hidden=true>, valueStart <hidden=true>, doExit <hidden=true>;
            if (lvl == -1) {
                while (exists(BehaviorTree.RawNodes.Node[kk]) ) {
                    if (lv == id_Tags) {
                        if (BehaviorTree.RawNodes.Node[kk].Tags.mTagsCount.Count > 1) {
                            for (tg=0; tg<BehaviorTree.RawNodes.Node[kk].Tags.mTagsCount.Count; tg++) {
                                valueStart = 0;
                                if ((exists(BehaviorTree.RawNodes.Node[kk].Tags.mTags.mTags[tg]) && BehaviorTree.RawNodes.Node[kk].Tags.mTags.mTags[tg] == hash )
                                || (!exists(BehaviorTree.RawNodes.Node[kk].Tags.mTags.mTags) && exists(BehaviorTree.RawNodes.Node[kk].Tags.mTags) && BehaviorTree.RawNodes.Node[kk].Tags.mTags == hash) ) {
                                    valueStart = startof(BehaviorTree.RawNodes.Node[kk]);
                                    if (!exists(ID) || startof(ID) != valueStart) {
                                        FSeek(valueStart);
                                        struct BHVTNode Node <name=ReadNodeTagsName, size=SizeBHVTNode>;
                                    }
                                } 
                            }
                        }
                    } else if (hash == BehaviorTree.RawNodes.Node[kk].ID.hash || hash == BehaviorTree.RawNodes.Node[kk].exID.hash) {
                        valueStart = startof(BehaviorTree.RawNodes.Node[kk]);
                        if (startof(ID) != valueStart) {
                            FSeek(valueStart);
                            struct BHVTNode Node <size=SizeBHVTNode, open=true>;
                        }
                        doExit = true;
                        break;
                    }
                    kk++;
                }
            }
            if (!doExit) { //search for RSZ structs
                (lv == -1) ? j=0 : j=lvl; 
                if (j==-1 || !exists(RSZFile[j]))
                    j=0;
                while(exists(RSZFile[j])) { 
                    i = 0;
                    while (exists(RSZFile[j].Data.RawData.RSZ[i])) {
                        k = 0;
                        while(exists(RSZFile[j].Data.RawData.RSZ[i].var[k])) {
                            if (exists(RSZFile[j].Data.RawData.RSZ[i].var[k].data)) 
                            
                            if (ReadInt(startof(RSZFile[j].Data.RawData.RSZ[i].var[k].data)) == hash) { // || 
                                FSeek(startof(RSZFile[j].Data.RawData.RSZ[i]));
                                lvl = j;
                                struct RSZInstance RSZ <open=true>; //size=SizeRSZInstance, 
                                if (lv != id_Tags) {
                                    doExit = true;
                                    break;
                                }
                            } 
                            k++;
                        }
                        i++;
                        if (doExit) break;
                    }
                    if (doExit || ((lv != -1 && lv != id_Actions) && (!exists(RSZFile[j+1]) || RSZFile[j+1].isUserData == false) )) 
                        break;
                    j++;
                }
            }
        }
        if (exists(this.Node) || exists(this.RSZ) || exists(this.TransitionMap))
            checkUseSpacers();
        FSeek(startof(hash)+4);
    }
} BHVTHash <open=suppress, optimize=false, read=ReadBHVTHash, write=WriteBHVTHash>;

    wstring ReadBHVTHash(BHVTHash &h) { 
        if (exists(h.Node)) 
            return ReadBHVTNode(h.Node); 
        if (exists(h.RSZ)) 
            return ReadRSZInstanceName(h.RSZ); 
        if (exists(h.Path))
            return ReadStringRead(h.Path);
        string s; 
        SPrintf(s, "%Xh", h.hash);
        return s; 
    } 
    
    void WriteBHVTHash(BHVTHash &h, string s) { h.hash = Atoi(s); } 

    //wstring ReadBHVTHashName(BHVTHash &h) { if (exists(h.RSZ)) return h.RSZ.name; return ""; } 

    int isActiveHash(BHVTHash &hash) {  return (hash.hash != 0 && hash.hash != -1) && (exists(hash.Node) || exists(hash.RSZ) || exists(hash.TransitionMap)); }

    int showHash(BHVTHash &hash){
        if (isActiveHash(hash)) {
            FSeek(startof(hash));
            return true;
        } return false;
    } 




//Start of RSZ Data =====================
FSeek(RSZOffset);
if (ReadUInt(0) == id_PFB || ReadUInt(0) == id_SCN) // SCN or PFB
    { FSkip(-1); BLANK __; FSkip(-1); BLANK MainDataNotice <name=ReadMainDataNotice>; }
while (FTell()+4 <= FileSize()) {
    if ( ReadUInt(FTell()) == 5919570 ) { //RSZ
        finished = false;
        if (level == 1 && !FEof()) { 
            if (Header.magic == id_PFB || Header.magic == id_SCN) {
                FSkip(-1); BLANK blank; 
                FSkip(-1); BLANK userDataNotice <name=ReadUserDataNotice>; 
            }
        }
        if (ReadUInt(FTell()+8) == 0)
            struct RSZMagic RSZFile <hidden=true>;
        else {
            //start at struct Data if there are embedded userdatas:
            if (ExposeUserDatas && ReadInt(FTell()+16) && (exists(GameObjectInfos.GameObjectInfo) || exists(BehaviorTree)) && (RSZVersion == "DMC5" || RSZVersion == "RE2")) { //has UserDatas
                realStart = FTell();
                FSeek(ReadUInt(realStart+32) + realStart);
                struct RSZMagic RSZFile;
            } else 
                struct RSZMagic RSZFile;
        }
        level++;
        FSeek(startof(RSZFile.RSZHeader) + 4);
    } else 
        FSkip(1);
}

finished = true;

if (!exists(Header)) { //detect strings in motbank etc files:
    FSeek(0);
    HashGenerator HashMaker <name="Hash Generator">;
    FSkip(-1);
    while(FTell() + 6 <= FileSize())
        if (detectedString(FTell()))
            StringRead Detected_String(FTell(), 0, true); //absolute
        else 
            FSkip(2);
}

//BehaviorTree
if (exists(BehaviorTree.RawNodes)) {
    FSeek(startof(BehaviorTree.RawNodes));
    checkUseSpacers();
    struct {
        local ushort az <hidden=true>;
        for (az=0; az<BehaviorTree.mNodeCount; az++) {
            if (az==0) {
                struct BHVTNode Node <name="Root Node", open=true>;
                checkUseSpacers();
            } else 
                struct BHVTNode Node <size=SizeBHVTNode>;
        }
    } Nodes;
} 


//RCOL only =======================================================
if (ReadUInt(0) == id_RCOL) { 
    FSeek(Header.groupsPtrTbl);
    struct {
        struct RcolGroup {
            struct {
                rGUID Guid;
                StringRead Name(-1, 0, 0);
                uint NameHash <format=hex>;
                int UserDataIndex;
                int NumShapes;
                int NumMaskGuids;
                uint64 ShapesTbl;
                int LayerIndex;
                uint MaskBits;
                uint64 MaskGuidsOffset;
                
                if (NumMaskGuids) {
                    FSeek(MaskGuidsOffset);
                    rGUID MaskGuids[NumMaskGuids] <optimize=false>;
                    FSeek(startof(MaskGuidsOffset)+8);
                }
                rGUID LayerGuid;
            } GroupInfo <name="[GroupInfo]">;
            
            FSeek(GroupInfo.ShapesTbl);
            if (GroupInfo.NumShapes)
                struct RcolShape {
                    struct RcolShapeInfo {
                        rGUID Guid;
                        StringRead Name(-1, 0, 0);
                        uint NameHash <format=hex>;
                        int UserDataIndex;
                        int LayerIndex;
                        int Attribute;
                        uint SkipIdBits;
                        uint IgnoreTagBits;
                        StringRead primaryJointNameStr(-1, 0, 0);
                        StringRead secondaryJointNameStr(-1, 0, 0);
                        uint PrimaryJointNameHash <format=hex>;
                        uint SecondaryJointNameHash <format=hex>;
                    } ShapeInfo <name="[ShapeInfo]", read=ReadRcolShapeInfo>;
            
                    enum <uint32> {
                        ShapeType_Aabb = 0x0,
                        ShapeType_Sphere = 0x1,
                        ShapeType_ContinuousSphere = 0x2,
                        ShapeType_Capsule = 0x3,
                        ShapeType_ContinuousCapsule = 0x4,
                        ShapeType_Box = 0x5,
                        ShapeType_Mesh = 0x6,
                        ShapeType_HeightField = 0x7,
                        ShapeType_StaticCompound = 0x8,
                        ShapeType_Area = 0x9,
                        ShapeType_Triangle = 0xA,
                        ShapeType_SkinningMesh = 0xB,
                        ShapeType_Cylinder = 0xC,
                        ShapeType_DeformableMesh = 0xD,
                        ShapeType_Invalid = 0xE,
                        ShapeType_Max = 0xF,
                    } ShapeType;
                    
                    FSkip(4);
                    struct {
                        float x, y, z, w;
                        float x, y, z, w;
                        float x, y, z, w;
                        float x, y, z, w;
                        float x, y, z, w;
                    } Parameters;
                    if (ShapeInfo.UserDataIndex) {
                        local ushort ObjectIndex <hidden=true> = RSZFile[0].ObjectTable[ShapeInfo.UserDataIndex];
                        FSeek(startof(RSZFile[0].Data.RawData.RSZ[ObjectIndex]));
                        struct RSZInstance RSZ <size=SizeRSZInstance>;
                        FSeek(startof(Parameters)+80);
                    }
                } Shape[GroupInfo.NumShapes] <read=ReadShape, optimize=false>; 
                
            FSeek(startof(GroupInfo.LayerGuid)+16);
            checkUseSpacers();

        } Group[Header.numGroups] <size=80, read=ReadGroup, optimize=false>;
    } Groups;
    
    if (exists(Header.numRequestSets) && Header.numRequestSets) {
        FSeek(Header.requestSetTbl);
        struct {
            local uint rcolArr[Header.numRequestSets] <hidden=true>;
            local uint rcolOffsetsArr[Header.numRequestSets] <hidden=true>;
            for (n=0; n<Header.numRequestSets; n++) { 
                rcolArr[n] = ReadUInt(); 
                rcolOffsetsArr[n] = FTell(); 
                FSkip(48); 
            }
            if (SortRequestSets)
                quicksort(0, Header.numRequestSets-1, rcolArr, rcolOffsetsArr); //Sort RequestSets by their IDs
            
            FSeek(Header.requestSetTbl);
            local uint endRequestSets <hidden=true>;
            for (n=0; n<Header.numRequestSets; n++) {
                FSeek(rcolOffsetsArr[n]);
                struct RcolRequestSet {
                    struct {
                        local ushort Index = (startof(this) - startof(RequestSets)) / 48;
                        uint ID;
                        int GroupIndex;
                        int ShapeOffset;
                        uint status;
                        StringRead Name(-1, 0, 0);
                        uint NameHash <format=hex>;
                        FSkip(4);
                        StringRead KeyName(-1, 0, 0);
                        uint KeyHash <format=hex>;
                    } RequestSetInfo <name="[RequestSetInfo]">;
                    local ushort ObjectIndex <hidden=true> = RSZFile.ObjectTable[RequestSetInfo.Index];
                    FSeek(startof(Groups.Group[RequestSetInfo.GroupIndex]));
                    struct RcolGroup Group <read=ReadGroup, size=80>;
                    
                    FSeek(startof(RSZFile.Data.RawData.RSZ[ObjectIndex]));
                    struct RSZInstance RSZ <size=SizeRSZInstance, open=true>;
                    
                    FSeek(startof(this)+48);
                } RequestSet <size=48, name=ReadRequestSetName, read=ReadRequestSet>;
                if (FTell() > endRequestSets) endRequestSets = FTell();
            }
            FSeek(endRequestSets);
        } RequestSets;
    }
} 
    wstring ReadGroup(RcolGroup &g) { return ReadWString(ReadUInt64(startof(g)+16)); }

    wstring ReadShape(RcolShape &s) { return s.ShapeInfo.Name.String; } 

    wstring ReadRequestSet(RcolRequestSet &a) { return ReadWString(ReadUInt(startof(a)+16)); }

    wstring ReadRequestSetName(RcolRequestSet &a) { string s; SPrintf(s, "RequestSet ID: %u  ", ReadUInt(startof(a))); return s; }

    wstring ReadRcolShapeInfo(RcolShapeInfo &r) { return r.primaryJointNameStr.String + "  " + r.secondaryJointNameStr.String; }